-- MysticOS - Server startup
--[[
Copyright © 2012 Esteban Hermida a.k.a MysticT

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
copies of the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-Visible credit is given to the original author.
-The software is distributed in a non-profit way.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]

-- Vars

local bShutdown = false
local bReboot = false

local sDir = ""
local tAliases = {}
local tProgramStack = {}

local shell = {}
local tEnv = { ["shell"]=shell, ["write"]= function(text) return term.write(text, true) end,
			["print"]=term.print, ["read"]=term.read, ["sleep"]=os.sleep }
tEnv._G = tEnv
setmetatable(tEnv, { __index = _G })

local tCommandHistory = {}

-- Load functions

function loadfile(sPath)
	local file = fs.open(sPath)
	if file:isOpen() then
		local func, err = loadstring(file:readAll(), sPath)
		file:close()
		if func then
			setfenv(func, tEnv)
		end
		return func, err
	end
	return nil, "File "..sPath.." not found."
end

function dofile(sFileName)
	local fnFile, err = loadfile(sPath)
	if fnFile then
		fnFile()
	else
		error(err)
	end
end

local function Run(sPath, ...)
	local func, err = loadfile(sPath)
	if not func then
		return false, err
	end
	setfenv(func, tEnv)
	return pcall(func, ...)
end

local function RunService(sPath, ...)
	local pid = os.createProcess(fs.getName(sPath))
	local func, err = loadfile(sPath)
	if not func then
		return false, err
	end
	local tid, err = os.createThread(pid, func)
	if not tid then
		return false, err
	end
	return true
end

local function LoadConfig()
	-- redstone state
	local ok, err = rs.loadState("os/config/redstone.state")
	if not ok then
		term.print("Error loading redstone state: ", err)
	end
	-- user config
	local tConfig, err = config.load("os/config/user.cfg")
	if tConfig then
		screen.setOutputMode(tonumber(tConfig.outputMode))
	else
		term.print("Error loading user configuration: ", err)
	end
end

local function SaveConfig()
	-- redstone state
	local ok, err = rs.saveState("os/config/redstone.state")
	if not ok then
		term.print("Error saving redstone state: ", err)
	end
	-- user config
	local tConfig = {}
	tConfig.outputMode = screen.getOutputMode()
	ok, err = config.save("os/config/user.cfg", tConfig)
	if not ok then
		term.print("Error saving user configuration: ", err)
	end
end

local function StartServices()
	local hFile = fs.open("os/config/services", "r")
	if hFile:isOpen() then
		local tLines = {}
		for sLine in hFile:lines() do
			table.insert(tLines, sLine)
		end
		for _,sLine in ipairs(tLines) do
			local tWords = {}
			for s in string.gmatch(sLine, "[^ \t]+") do
				table.insert(tWords, s)
			end
			if tWords[1] then
				local ok, err = shell.runService(unpack(tWords))
				if not ok then
					term.print("Error starting service ", tWords[1], ": ", err)
				end
			end
		end
	end
end

local function Autorun()
	local hFile = fs.open("os/config/autorun", "r")
	if hFile:isOpen() then
		local tLines = {}
		for sLine in hFile:lines() do
			table.insert(tLines, sLine)
		end
		for _,sLine in ipairs(tLines) do
			local tWords = {}
			for s in string.gmatch(sLine, "[^ \t]+") do
				table.insert(tWords, s)
			end
			if tWords[1] then
				local ok, err = shell.run(unpack(tWords))
				if not ok then
					term.print(err)
				end
			end
		end
	end
end

-- Shell API

function shell.run(sCommand, ...)
	local sPath = shell.resolveProgram(sCommand)
	if sPath ~= nil then
		table.insert(tProgramStack, sPath)
   		local ok, result = Run(sPath, ...)
		table.remove(tProgramStack)
		return ok, result
   	else
    	return false, "No such program"
    end
end

function shell.runService(sCommand, ...)
	local sPath = shell.resolveProgram(sCommand)
	if sPath ~= nil then
   		local ok, result = RunService(sPath, ...)
		return ok, result
   	else
    	return false, "No such program"
    end
end

function shell.exit()
	SaveConfig()
    bShutdown = true
end

function shell.shutdown()
	SaveConfig()
	bShutdown = true
end

function shell.reboot()
	SaveConfig()
	bReboot = true
	bShutdown = true
end

function shell.dir()
	return sDir
end

function shell.setDir(dir)
	sDir = dir
end

function shell.resolve(sPath)
	local sStartChar = string.sub(sPath, 1, 1)
	if sStartChar == "/" or sStartChar == "\\" then
		return fs.combine("", sPath)
	else
		return fs.combine(sDir, sPath)
	end
end

function shell.resolveProgram(sCommand)
	-- Substitute aliases firsts
	if tAliases[sCommand] ~= nil then
		sCommand = tAliases[sCommand]
	end
	-- If the path is a global path, use it directly
    local sStartChar = string.sub(sCommand, 1, 1)
    if sStartChar == "/" or sStartChar == "\\" then
    	local sPath = fs.combine("", sCommand)
    	if fs.exists(sPath) and not fs.isDir(sPath) then
			return sPath
    	end
		return nil
    end
	-- Otherwise, look on the path
    for sPath in string.gmatch(os.getEnvVar("Path"), "[^;]+") do
    	sPath = fs.combine(shell.resolve(sPath), sCommand)
    	if fs.exists(sPath) and not fs.isDir(sPath) then
			return sPath
    	end
    end
	-- Not found
	return nil
end

function shell.programs(bIncludeHidden)
	local tItems = {}
	-- Add programs from the path
    for sPath in string.gmatch(os.getEnvVar("Path"), "[^;]+") do
		sPath = shell.resolve(sPath)
		if fs.isDir(sPath) then
			local tList = fs.list(sPath, bIncludeHidden)
			for n, sFile in pairs(tList) do
				if not fs.isDir(fs.combine(sPath, sFile)) then
					tItems[sFile] = true
				end
			end
		end
    end	
	-- Sort and return
	local tItemList = {}
	for sItem, b in pairs(tItems) do
		table.insert(tItemList, sItem)
	end
	table.sort(tItemList)
	return tItemList
end

function shell.getRunningProgram()
	if #tProgramStack > 0 then
		return tProgramStack[#tProgramStack]
	end
	return nil
end

function shell.setAlias(sCommand, sProgram)
	tAliases[sCommand] = sProgram
end

function shell.clearAlias(sCommand)
	tAliases[sCommand] = nil
end

function shell.aliases()
	return table.copy(tAliases)
end

-- Main loop

os.setEnvVar("Path", "/bin;.")
os.setEnvVar("HelpPath", "/help")

term.clear()
term.setCursorPos(1, 1)
term.print(os.version())
LoadConfig()
StartServices()
Autorun()

while not bShutdown do
	term.write(sDir.."> ")
	local sLine = term.read(nil, tCommandHistory)
	table.insert(tCommandHistory, sLine)
	local tWords = {}
	for s in string.gmatch(sLine, "[^ \t]+") do
		table.insert(tWords, s)
	end
	local sCommand = tWords[1]
	if sCommand then
		local ok, err = shell.run(sCommand, unpack(tWords, 2))
		if not ok then
			term.print(err)
		end
	end
end

if bReboot then
	os.reboot()
end