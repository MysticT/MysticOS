-- Terminal Lib for MysticOS
--[[
Copyright © 2012 Esteban Hermida a.k.a MysticT

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
copies of the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-Visible credit is given to the original author.
-The software is distributed in a non-profit way.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]

-- Lib functions

--[[
- getSize (function)
	* gets the size of the output
	* return values:
		- the horizontal size of the output (number)
		- the vertical size of the output (number)
--]]
function getSize()
	return screen.getSize()
end

--[[
- clear (function)
	* clears the output
--]]
function clear()
	screen.clear()
end

--[[
- clearLine (function)
	* clears a line of the output
	* parameters:
		- nLine: the number of line to clear (number) [optional]
--]]
function clearLine(nLine)
	screen.clearLine(nLine)
end

--[[
- getCursorPos (function)
	* gets the cursor position
	* return values:
		- the horizontal position of the cursor (number)
		- the vertical position of the cursor (number)
--]]
function getCursorPos()
	return screen.getCursorPos()
end

--[[
- setCursorPos (function)
	* moves the cursor to the specified position
	* parameters:
		- x: the horizontal position of the cursor (number)
		- y: the vertical position of the cursor (number)
--]]
function setCursorPos(x, y)
	screen.setCursorPos(x, y)
end

--[[
- setCursorBlink (function)
	* sets the cursor blinking mode
	* parameters:
		- b: true to make the cursor blink, false to make it stop (boolean)
--]]
function setCursorBlink(b)
	screen.setCursorBlink(b)
end

--[[
- scroll (function)
	* scrolls the screen vertically, moving the text up
	* parameters:
		- n: the number of lines to scroll (number)
--]]
function scroll(n)
	screen.scroll(n)
end

--[[
- write (function)
	* writes text to the screen
	* return values:
		- the number of lines used to write (number)
	* parameters:
		- txt: the text to write (any type)
		- bWrap: boolean indicating if the text should wrap when it gets to the end of the line (boolean)
--]]
function write(sText, bWrap)
	CheckVarTypes(bWrap, "nil", "boolean")
	sText = tostring(sText)
	if bWrap then
		local nLines = 0
		local x, y = getCursorPos()
		local w, h = getSize()
		local function newline()
			if y + 1 <= h then
				setCursorPos(1, y + 1)
			else
				scroll(1)
				setCursorPos(1, h)
			end
			x, y = getCursorPos()
			nLines = nLines + 1
		end
		while #sText > 0 do
			local space = string.match(sText, "^([ \t]+)")
			if space then
				screen.write(space)
				x, y = getCursorPos()
				sText = string.sub(sText, #space + 1)
			end
			while string.sub(sText, 1, 1) == "\n" do
				newline()
				sText = string.sub(sText, 2)
			end
			if #sText > 0 then
				local txt = string.match(sText, "^[^ \t\n]+")
				if txt then
					sText = string.sub(sText, #txt + 1)
					if #txt > w then
						while #txt > 0 do
							if x > w then
								newline()
							end
							screen.write(txt)
							txt = string.sub(txt, (w - x) + 2)
							x, y = getCursorPos()
						end
					else
						if #txt > w - x then
							newline()
						end
						screen.write(txt)
						x, y = getCursorPos()
					end
				end
			end
		end
		return nLines
	else
		screen.write(sText)
		return 1
	end
end

--[[
- print (function)
	* prints text on the screen, adding a new line at the end
	* return values:
		- the number of lines printed (number)
	* parameters:
		- any value to print
--]]
function print(...)
	local nLines = 0
	local tArgs = { ... }
	for i = 1, #tArgs do
		nLines = nLines + write(tostring(tArgs[i]), true)
	end
	nLines = nLines + write("\n", true)
	return nLines
end

--[[
- read (function)
	* gets user input
	* return values:
		- the text entered by the user (string)
	* parameters:
		- sReplaceChar: character to use as replacement for the entered text (string) [optional]
		- tHistory: history table (table) [optional]
		- nMax: maximum number of characters to read (number) [optional]
--]]
function read(sReplaceChar, tHistory, nMax)
	CheckVarTypes(sReplaceChar, "nil", "string")
	CheckVarTypes(tHistory, "nil", "table")
	CheckVarTypes(nMax, "nil", "number")
	setCursorBlink(true)
	local sLine = ""
	local nHistoryPos = nil
	local nPos = 0
	if sReplaceChar then
		sReplaceChar = string.sub(sReplaceChar, 1, 1)
	end
	local w, h = getSize()
	local sx, sy = getCursorPos()
	local function redraw()
		local nScroll = 0
		if sx + nPos >= w then
			nScroll = (sx + nPos) - w
		end
		setCursorPos(sx, sy)
		screen.write(string.rep(" ", w - sx + 1))
		setCursorPos(sx, sy)
		if sReplaceChar then
			screen.write(string.rep(sReplaceChar, #sLine - nScroll))
		else
			screen.write(string.sub(sLine, nScroll + 1 ))
		end
		setCursorPos(sx + nPos - nScroll, sy)
	end
	while true do
		local sEvent, param = os.pullEvent("char", "key")
		if sEvent == "char" then
			if not nMax or #sLine < nMax then
				sLine = string.sub(sLine, 1, nPos)..param..string.sub(sLine, nPos + 1)
				nPos = nPos + 1
				redraw()
			end
		elseif sEvent == "key" then
			if param == keys.Enter then
				break
			elseif param == keys.Left then
				if nPos > 0 then
					nPos = nPos - 1
					redraw()
				end
			elseif param == keys.Right then
				if nPos < string.len(sLine) then
					nPos = nPos + 1
					redraw()
				end
			elseif param == keys.Up or param == keys.Down then
				if tHistory then
					if param == keys.Up then
						if nHistoryPos == nil then
							if #tHistory > 0 then
								nHistoryPos = #tHistory
							end
						elseif nHistoryPos > 1 then
							nHistoryPos = nHistoryPos - 1
						end
					else
						if nHistoryPos == #tHistory then
							nHistoryPos = nil
						elseif nHistoryPos ~= nil then
							nHistoryPos = nHistoryPos + 1
						end						
					end
					if nHistoryPos then
						sLine = tHistory[nHistoryPos]
						nPos = string.len(sLine)
					else
						sLine = ""
						nPos = 0
					end
					redraw()
				end
			elseif param == keys.Backspace then
				if nPos > 0 then
					sLine = string.sub(sLine, 1, nPos - 1)..string.sub(sLine, nPos + 1)
					nPos = nPos - 1
					redraw()
				end
			elseif param == keys.Del then
				sLine = string.sub(sLine, 1, nPos)..string.sub(sLine, nPos + 2)
				redraw()
			elseif param == keys.Home then
				nPos = 0
				redraw()
			elseif param == keys.End then
				nPos = #sLine
				redraw()
			end
		end
	end
	setCursorBlink(false)
	setCursorPos(w + 1, sy)
	print()
	return sLine
end