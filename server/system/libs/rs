-- Redstone Lib for MysticOS
--[[
Copyright © 2012 Esteban Hermida a.k.a MysticT

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
copies of the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-Visible credit is given to the original author.
-The software is distributed in a non-profit way.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]

local tSides = ccrs.getSides()

local tOutput = {}
local tInput = {}
local tBInput = {}

local function SetOutput(side, b)
	ccrs.setOutput(side, b)
	tOutput[side] = b
end

local function AddOutput(side, c)
	ccrs.setBundledOutput(side, colors.combine(ccrs.getBundledOutput(side), c))
end

local function RemoveOutput(side, c)
	ccrs.setBundledOutput(side, colors.subtract(ccrs.getBundledOutput(side), c))
end

-- Lib functions

function getSides()
	return ccrs.getSides()
end

function setOutput(side, b)
	if b == nil then
		if type(side) == "table" then
			-- setOutput(table)
			for s, v in pairs(side) do
				SetOutput(s, v)
			end
		else
			-- setOutput(boolean)
			for _,s in ipairs(tSides) do
				SetOutput(s, side)
			end
		end
	else
		if type(side) == "table" then
			-- setOutput(table, boolean)
			for _,s in ipairs(side) do
				SetOutput(s, b)
			end
		else
			-- setOutput(string, boolean)
			SetOutput(side, b)
		end
	end
end

function getInput(side)
	if side == nil then
		-- getInput()
		local t = {}
		for _,s in ipairs(tSides) do
			t[s] = ccrs.getInput(s)
		end
		return t
	elseif type(side) == "table" then
		-- getInput(table)
		local t = {}
		for _,s in ipairs(side) do
			t[s] = ccrs.getInput(s)
		end
		return t
	else
		-- getInput(string)
		return ccrs.getInput(side)
	end
end

function getBundledInput(side)
	if side == nil then
		-- getBundledInput()
		local t = {}
		for _,s in ipairs(tSides) do
			t[s] = ccrs.getBundledInput(s)
		end
		return t
	elseif type(side) == "table" then
		-- getBundledInput(table)
		local t = {}
		for _,s in ipairs(side) do
			t[s] = ccrs.getBundledInput(s)
		end
		return t
	else
		-- getBundledInput(string)
		return ccrs.getBundledInput(side)
	end
end

function testBundledInput(side, nColors)
	if nColors == nil then
		if type(side) == "table" then
			-- testBundledInput(table)
			for s, c in pairs(side) do
				if not ccrs.testBundledInput(s, c) then
					return false
				end
			end
			return true
		else
			-- testBundledInput(number)
			for _,s in ipairs(tSides) do
				if not ccrs.testBundledInput(s, nColors) then
					return false
				end
			end
			return true
		end
	else
		if type(side) == "table" then
			-- testBundledInput(table, number)
			for _,s in ipairs(side) do
				if not ccrs.testBundledInput(s, nColors) then
					return false
				end
			end
			return true
		else
			-- testBundledInput(string, number)
			return ccrs.testBundledInput(side, nColors)
		end
	end
end

function setBundledOutput(side, nColors)
	if nColors == nil then
		if type(side) == "table" then
			-- setBundledOutput(table)
			for s, c in pairs(side) do
				ccrs.setBundledOutput(s, c)
			end
		else
			-- setBundledOutput(number)
			for _,s in ipairs(tSides) do
				ccrs.setBundledOutput(s, side)
			end
		end
	else
		if type(side) == "table" then
			-- setBundledOutput(table, number)
			for _,s in ipairs(side) do
				ccrs.setBundledOutput(s, nColors)
			end
		else
			-- setBundledOutput(string, number)
			ccrs.setBundledOutput(side, nColors)
		end
	end
end

function getBundledOutput(side)
	if side == nil then
		-- getBundledOutput()
		local t = {}
		for _,s in ipairs(tSides) do
			t[s] = ccrs.getBundledOutput(s)
		end
		return t
	elseif type(side) == "table" then
		-- getBundledOutput(table)
		local t = {}
		for _,s in ipairs(side) do
			t[s] = ccrs.getBundledOutput(s)
		end
		return t
	else
		-- getBundledOutput(string)
		return ccrs.getBundledOutput(side)
	end
end

function addBundledOutput(side, nColors)
	if nColors == nil then
		if type(side) == "table" then
			-- addBundledOutput(table)
			for s, c in pairs(side) do
				AddBundledOutput(s, c)
			end
		else
			-- addBundledOutput(number)
			for _,s in ipairs(tSides) do
				AddBundledOutput(s, side)
			end
		end
	else
		if type(side) == "table" then
			-- addBundledOutput(table, number)
			for _,s in ipairs(side) do
				AddBundledOutput(s, nColors)
			end
		else
			-- addBundledOutput(string, number)
			AddBundledOutput(side, nColors)
		end
	end
end

function removeBundledOutput(side, nColors)
	if nColors == nil then
		if type(side) == "table" then
			-- removeBundledOutput(table)
			for s, c in pairs(side) do
				RemoveBundledOutput(s, c)
			end
		else
			-- removeBundledOutput(number)
			for _,s in ipairs(tSides) do
				RemoveBundledOutput(s, side)
			end
		end
	else
		if type(side) == "table" then
			-- removeBundledOutput(table, number)
			for _,s in ipairs(side) do
				RemoveBundledOutput(s, nColors)
			end
		else
			-- removeBundledOutput(string, number)
			RemoveBundledOutput(side, nColors)
		end
	end
end

function pulse(side, nTime)
	if side then
		setOutput(side, true)
		os.sleep(nTime / 2)
		setOutput(side, false)
		os.sleep(nTime / 2)
	else
		setOutput(true)
		os.sleep(nTime / 2)
		setOutput(false)
		os.sleep(nTime / 2)
	end
end

function bundledPulse(side, nColors, nTime)
	if side then
		addBundledOutput(side, nColors)
		os.sleep(nTime / 2)
		removeBundledOutput(side, nColors)
		os.sleep(nTime / 2)
	else
		addBundledOutput(nColors)
		os.sleep(nTime / 2)
		removeBundledOutput(nColors)
		os.sleep(nTime / 2)
	end
end

function saveState(sFileName)
	local file = fs.open(sFileName, "w")
	if file:isOpen() then
		local tBOut = getBundledOutput()
		for _,s in ipairs(tSides) do
			file:write(s.." = ")
			file:write(tostring(tOutput[s]))
			file:writeLine(", "..tostring(tBOut[s]))
		end
		file:close()
		return true
	end
	return false, "Error opening file "..sFileName
end

function loadState(sFileName)
	local file = fs.open(sFileName, "r")
	if file:isOpen() then
		local tOut = {}
		local tBOut = {}
		local sLine = file:readLine()
		while sLine do
			local sSide, sOut, sBOut = string.match(sLine, "(%a+) = (%a+), (%d+)")
			if sSide == nil or sOut == nil or sBOut == nil then
				file:close()
				return false, "Error loading state."
			end
			local bOut
			if sOut == "true" then
				bOut = true
			elseif sOut == "false" then
				bOut = false
			end
			local nBOut = tonumber(sBOut)
			if bOut == nil or nBOut == nil then
				file:close()
				return false, "Error loading state."
			end
			tOut[sSide] = bOut
			tBOut[sSide] = nBOut
			sLine = file:readLine()
		end
		file:close()
		setOutput(tOut)
		setBundledOutput(tBOut)
		return true
	else
		return false, "Error opening file "..sFileName
	end
end

-- Set Event Handlers

sys.addEventHandler("redstone", function()
	for s, c in pairs(getBundledInput()) do
		if tBInput[s] ~= c then
			os.queueEvent("Redstone", "bundled", s, tBInput[s], c)
			tBInput[s] = c
			return true
		end
	end
	for s, b in pairs(getInput()) do
		if tInput[s] ~= b then
			os.queueEvent("Redstone", "normal", s, tInput[s], b)
			tInput[s] = b
			break
		end
	end
	return true
end)

for _,s in ipairs(tSides) do
	tOutput[s] = false
	tInput[s] = getInput(s)
	tBInput[s] = 0
end