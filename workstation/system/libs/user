-- Users Lib for MysticOS
--[[
Copyright © 2012 Esteban Hermida a.k.a MysticT

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
copies of the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-Visible credit is given to the original author.
-The software is distributed in a non-profit way.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]

-- User Levels
local nNormalLevel = 1
local nAdminLevel = 2

NormalLevel = nNormalLevel
AdminLevel = nAdminLevel

-- local vars and functions

local MinLevel = nNormalLevel
local MaxLevel = nAdminLevel

local tGroups
local tUsers

local function load_groups()
	if tGroups == nil then
		local file = ccfs.open(ccfs.combine(sys.osDir(), "system/groups"), "r")
		if file then
			tGroups = {}
			local sLine = file.readLine()
			while sLine do
				local g, l = string.match(sLine, "(%w+) (%d)")
				if g and l then
					tGroups[g] = l
				end
				sLine = file.readLine()
			end
			file.close()
		end
	end
end

local function save_groups()
	if tGroups then
		local file = ccfs.open(ccfs.combine(sys.osDir(), "system/groups"), "w")
		if not file then
			return false, "Error opening groups file."
		end
		for g, l in pairs(tGroups) do
			file.write(g.." "..l.."\n")
		end
		file.close()
	end
	return true
end

local function load_users()
	if tUsers == nil then
		local file = ccfs.open(ccfs.combine(sys.osDir(), "system/users"), "r")
		if file then
			tUsers = {}
			local sLine = file.readLine()
			while sLine do
				local u, p, g = string.match(sLine, "(%w+)%s(%w+)%s(%w+)")
				if u and p and g then
					tUsers[u] = {}
					tUsers[u].pass = p
					tUsers[u].group = g
				end
				sLine = file.readLine()
			end
			file.close()
		end
	end
end

local function save_users(tUsers)
	if tUsers then
		local file = ccfs.open(ccfs.combine(sys.osDir(), "system/users", "w"))
		if not file then
			return false, "Error opening users file."
		end
		for u, t in pairs(tUsers) do
			file.write(u.." "..t.pass.." "..t.group.."\n")
		end
		file.close()
	end
	return true
end

local function AddUser(sUser, sPass, sGroup)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tUsers[sUser] ~= nil then
		return false, "User already exists."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exist."
	end
	tUsers[sUser] = {}
	tUsers[sUser].pass = hash.sha256(sPass)
	tUsers[sUser].group = sGroup
	return save_users()
end

local function DelUser(sUser)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	if tUsers[sUser] == nil then
		return false, "User doesn't exists."
	end
	tUsers[sUser] = nil
	return save_users()
end

local function ChangePass(sUser, sPass)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	if tUsers[sUser] == nil then
		return false, "User doesn't exists."
	end
	tUsers[sUser].pass = hash.sha256(sPass)
	return save_users()
end

local function ChangeUserGroup(sUser, sGroup)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	if tUsers[sUser] == nil then
		return false, "Users doesn't exist."
	end
	load_groups()
	if tGroups == nil then
		return false, "Error loading groups."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exist."
	end
	tUsers[tUser].group = sGroup
	return save_users()
end

local function CheckUser(sUser, sPass)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	return tUsers[sUser] ~= nil and hash.sha256(sPass) == tUsers[sUser].pass
end

local function ValidateUsername(sName)
	if #sName < 4 then
		return false, "Username is to short."
	end
	if string.match(sName, "[^%w]") then
		return false, "Username can't contain spaces or symbols."
	end
	return true
end

local function AddGroup(sGroup, nLevel)
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tGroups[sGroup] then
		return false, "Group already exists."
	end
	if nLevel < MinLevel or nLevel > MaxLevel then
		return false, "Invalid level."
	end
	tGroups[sGroup] = nLevel
	return save_groups()
end

local function DelGroup(sGroup)
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exists."
	end
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	for _,u in pairs(tUsers) do
		if u.group == sGroup then
			return false, "Can't remove group with users."
		end
	end
	tGroups[sGroup] = nil
	return save_groups()
end

local function ChangeGroupLevel(sGroup, nLevel)
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exist."
	end
	if nLevel < MinLevel or nLevel > MaxLevel then
		return false, "Invalid level."
	end
	tGroups[sGroup] = nLevel
	return save_groups()
end

local tReservedGroupNames = { "System" }

local function ValidateGroupName(sName)
	if #sName < 4 then
		return false, "Group Name is to short."
	end
	if string.match(sName, "[^%w]") then
		return false, "Group Name can't contain spaces or symbols."
	end
	if table.contains(tReservedGroupNames, sName) then
		return false, "Invalid group name."
	end
	return true
end

local function LoadUserEnv()
	-- Load User Libs
	if not fs.exists("os/libs") or not fs.isDir("os/libs") then
		if fs.exists("os/libs") then
			fs.delete("os/libs")
		end
		fs.makeDir("os/libs")
	end
	local tUsrLibs = fs.list("os/libs")
	for _, sName in ipairs(tUsrLibs) do
		local sFile = fs.combine("os/libs", sName)
		if not fs.isDir(sFile) then
			os.loadSharedLib(sFile)
		end
	end
	-- Set Environment Variables
	os.setEnvVar("User", getUserName())
	os.setEnvVar("Path", "/bin;.")
	os.setEnvVar("HelpPath", "/help")
end

-- Lib functions

local bLogged = false
local sCurUser = ""

function login(sUser, sPass)
	CheckVarsType("string", sUser, sPass)
	if bLogged then
		if sUser ~= sCurUser then
			return false, "There's another user logged"
		end
		return true
	end
	if not CheckUser(sUser, sPass) then
		return false, "Invalid username/password."
	end
	bLogged = true
	sCurUser = sUser
	LoadUserEnv()
	return true
end

function logout()
	bLogged = false
	sCurUser = ""
	os.unloadSharedLibs()
	os.clearEnvVars()
end

function isLogged()
	return bLogged
end

function getUserName()
	return sCurUser
end

function getUserGroup()
	return tUsers[sCurUser].group
end

function getUserLevel()
	load_groups()
	if tGroups == nil then
		return nil, "Error loading user groups."
	end
	return tGroups[tUsers[sCurUser].group]
end

function createUser(sUser, sPass, sGroup)
	CheckVarsType("string", sUser, sPass)
	if getUserLevel() < nAdminLevel then
		return false, "Admin level required."
	end
	local ok, err = ValidateUsername(sUser)
	if not ok then
		return false, err
	end
	ok, err = AddUser(sUser, sPass, sGroup)
	if not ok then
		return false, err
	end
	local sUsrDir = ccfs.combine(ccfs.combine(sys.osDir(), "users"), sUser)
	ccfs.copy(ccfs.combine(sys.osDir(), "system/common"), sUsrDir)
	return true
end

function removeUser(sUser)
	CheckVarType(sUser, "string")
	if getUserLevel() < nAdminLevel then
		return false, "Admin level required."
	end
	if sUser == sCurUser then
		return false, "Can't remove current user."
	end
	local ok, err = DelUser(sUser)
	if not ok then
		return false, err
	end
	ccfs.delete(ccfs.combine(ccfs.combine(sys.osDir(), "users", sUser)))
	return true
end

function changePassword(sUser, sOldPass, sNewPass)
	CheckVarsType("string", sUser, sOldPass, sNewPass)
	if sUser ~=sCurUser and getUserLevel() < nAdminLevel then
		return false, "Admin level required."
	end
	local ok, err = CheckUser(sUser, sOldPass)
	if not ok then
		return false, err
	end
	return ChangePass(sUser, sNewPass)
end

function createGroup(sGroup, nLevel)
	CheckVarType(sGroup, "string")
	CheckVarType(nLevel, "number")
	if getUserLevel() < nAdminLevel then
		return false, "Admin level required."
	end
	local ok, err = ValidateGroupName(sGroup)
	if not ok then
		return false, err
	end
	return AddGroup(sGroup, nLevel)
end

function removeGroup(sGroup)
	CheckVarType(sGroup, "string")
	if getUserLevel() < nAdminLevel then
		return false, "Admin level required."
	end
	return DelGroup(sGroup)
end

function changeGroupLevel(sGroup, nLevel)
	CheckVarType(sGroup, "string")
	CheckVarType(nLevel, "number")
	if getUserLevel() < nAdminLevel then
		return false, "Admin level required."
	end
	return ChangeGroupLevel(sGroup, nLevel)
end

function getUsers()
	load_users()
	if tUsers == nil then
		return nil, "Error loading users."
	end
	local t = {}
	for name,_ in pairs(tUsers) do
		table.insert(t, name)
	end
	return t
end

function getUserCount()
	load_users()
	if tUsers == nil then
		return 0
	end
	return #tUsers
end

function getGroups()
	load_groups()
	if tGroups == nil then
		return nil, "Error loading groups."
	end
	local t = {}
	for name,_ in pairs(tGroups) do
		table.insert(t, name)
	end
	return t
end

function getGroupCount()
	load_groups()
	if tGroups == nil then
		return 0
	end
	return #tGroups
end