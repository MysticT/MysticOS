-- MysticOS - WorkStation Version
--[[
Copyright © 2012 Esteban Hermida a.k.a MysticT

Permission is hereby granted, free of charge, to any person obtaining a copy of this software and
associated documentation files (the "Software"), to deal in the Software without restriction,
including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense,
copies of the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

-The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
-Visible credit is given to the original author.
-The software is distributed in a non-profit way.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
--]]

-- Version String
local sVersion = "MysticOS - WorkStation 1.0 pr1"
-- Version Number
local nVersion = 1.0
-- OS Directory
local sOsDir = "MOS-WS"

-- table functions

--[[
- table.contains (function)
	* checks if the table contains the given value
	* return values:
		- boolean indicating if the table contains the value (boolean)
	* parameters:
		- t: the table to check (table)
		- val: the value to search
--]]
function table.contains(t, val)
	for _, v in pairs(t) do
		if v == val then
			return true
		end
	end
	return false
end

--[[
- table.contains_key (function)
	* checks if the table contains the given key
	* return values:
		- boolean indicating if the table contains the key (boolean)
	* parameters:
		- t: the table to check (table)
		- key: the key to search
--]]
function table.contains_key(t, key)
	return t[key] ~= nil
end

--[[
- table.clear (function)
	* removes every key and value from the table
	* parameters:
		- t: the table to clear (table)
--]]
function table.clear(t)
	local k = next(t)
	while k do
		t[k] = nil
		k = next(t)
	end
end

--[[
- table.copy (function)
	* makes a copy of the table
	* return values:
		- the copied table (table)
	* parameters:
		- t: the table to copy (table)
--]]
function table.copy(t)
	local cp = {}
	for k, v in pairs(t) do
		cp[k] = v
	end
	return cp
end

--[[
- table.keys (function)
	* gets a list of all the keys in this table
	* return values:
		- the list of keys (table)
	* parameters:
		- t: the table to get the keys (table)
--]]
function table.keys(t)
	local tKeys = {}
	local k = next(t)
	while k do
		table.insert(tKeys, k)
		k = next(t)
	end
end

--[[
- table.keys (function)
	* gets a list of all the values in this table
	* return values:
		- the list of values (table)
	* parameters:
		- t: the table to get the values (table)
--]]
function table.values(t)
	local tValues = {}
	local k, v = next(t)
	while k do
		table.insert(tValues, k)
		k, v = next(t)
	end
end

--[[
- table.size (function)
	* gets the size of the table (includes non-numeric indices)
	* return values:
		- the size of the table (number)
	* parameters:
		- t: the table to get it's size (table)
--]]
function table.size(t)
	local i = 0
	local k = next(t)
	while k do
		i = i + 1
		k = next(t)
	end
	return i
end

-- workaround for a bug in LuaJ
local s_sub = string.sub
function string.sub(s, i, j)
	return s_sub(s, i, j)..""
end

-- Type checking functions

--[[
- CheckVarType (function)
	* checks whether a variable is of the given type, throws an error if it's not
	* parameters:
		- v: the variable to check
		- e: the expected type (string)
--]]
function CheckVarType(v, e)
	local t = type(v)
	if t ~= e then
		error("Bad argument: "..e.." expected, got "..t)
	end
end

--[[
- CheckVarTypes (function)
	* checks whether a variable is of any of the given types, throws an error if it's not
	* parameters:
		- v: the variable to check
		- ...: the expected types (string)
--]]
function CheckVarTypes(v, ...)
	local t = type(v)
	local e = nil
	for _,v in ipairs({ ... }) do
		if t == v then return end
		e = v
	end
	error("Bad argument: "..e.." expected, got "..t)
end

--[[
- CheckVarsType (function)
	* checks whether the given variables are of the given type, throws an error if they aren't
	* parameters:
		- e: the expected type (string)
		- ...: the variables to check
--]]
function CheckVarsType(e, ...)
	for _, v in ipairs({ ... }) do
		local t = type(v)
		if t ~= e then
			error("Bad argument: "..e.." expected, got "..t)
		end
	end
end

-- Load functions

--[[
- load (function)
	* loads a chunk using a function to get its pieces
	* return values:
		- the loaded chunk, nil on error (function, nil)
		- the error message, if any (string, nil)
	* parameters:
		- f: the function to get the chunk pieces (function)
		- n: the chunk name (string) [optional]
		- tEnv: the function environment (table) [optional]
--]]
local function load(f, n, tEnv)
	local fun, err = _G.load(f, n)
	if fun and tEnv then
		setfenv(fun, tEnv)
	end
	return fun, err
end

--[[
- loadstring (function)
	* loads a chunk from the given string
	* return values:
		- the loaded chunk, nil on error (function, nil)
		- the error message, if any (string, nil)
	* parameters:
		- s: the chunk to load (string)
		- n: the chunk name (string) [optional]
		- tEnv: the function environment (table) [optional]
--]]
local function loadstring(s, n, tEnv)
	local fun, err = _G.loadstring(s, n)
	if fun and tEnv then
		setfenv(fun, tEnv)
	end
	return fun, err
end

--[[
- loadfile (function)
	* loads a chunk from the given file
	* return values:
		- the loaded chunk, nil on error (function, nil)
		- the error message, if any (string, nil)
	* parameters:
		- sPath: the path to the file to load (string)
		- tEnv: the function environment (table) [optional]
--]]
local function loadfile(sPath, tEnv)
	local file = fs.open(sPath, "r")
	if file then
		local s = file.readAll()
		file.close()
		return loadstring(s, sPath, tEnv)
	end
	return nil, "File "..sPath.." not found."
end

--[[
- dofile (function)
	* loads and executes a chunk from the given file
	* return values:
		- any value returned by the chunk
	* parameters:
		- sPath: the path to the file to load (string)
		- tEnv: the function environment (table) [optional]
--]]
local function dofile(sPath, tEnv)
	local fnFile, err = loadfile(sPath, tEnv)
	if fnFile then
		return fnFile()
	else
		error(err)
	end
end

-- System functions

--[[
- bProtected (boolean)
	* when true, the tables protected with the protect function can't be modified
--]]
local bProtected = true

--[[
- protect (function)
	* protects a table from user modification
	* parameters:
		- tbl: the table to protect (table)
--]]
local function protect(tbl)
	local m = getmetatable(tbl)
	if m ~= "PROTECTED" then
		setmetatable(tbl, {
			__newindex = function(t, k, v)
				if bProtected then
					error("Attempt to write to global")
				else
					rawset(t, k, v)
				end
			end,
			__metatable = "PROTECTED"
		} )
	end
end

-- Environment variables
--[[
- tSysEnv (table)
	* system environment, contains all the global variables and functions used by the system libs
--]]
local tSysEnv = {}

--[[
- tSharedEnv (table)
	* shared environment, contains all the global variables and functions used by the shared libs and user programs
--]]
local tSharedEnv = {}

-- Execution variables
--[[
- bTerminate (boolean)
	* when true, the computer shuts down
--]]
local bTerminate = false
--[[
- bReboot (boolean)
	* if true the computer will reboot after shutdown
--]]
local bReboot = false

--[[
- InitSysEnv (function)
	* initializes the system environment with all the global variables and functions
	* loaded variables and functions:
		- every variable and function in the global environment (except the fs, os and rs APIs)
		- ccfs: the ComputerCraft file system API
		- ccos: the ComputerCraft OS API
		- getfenv/setfenv: modified version of the functions to protect the global environment
		- load/loadstring/loadfile/dofile: modified version of the functions that sets the system environment for the loaded functions
--]]
local function InitSysEnv()
	-- Global functions
	for k, v in pairs(_G) do
		tSysEnv[k] = v
	end
	
	-- rename some APIs
	tSysEnv.fs = nil
	tSysEnv.ccfs = fs
	tSysEnv.os = nil
	tSysEnv.ccos = os
	tSysEnv.peripheral = nil
	tSysEnv.ccperiph = peripheral
	tSysEnv.term = nil
	tSysEnv.ccterm = term
	tSysEnv.rs = nil
	tSysEnv.redstone = nil
	tSysEnv.ccrs = rs
	
	-- env functions
	tSysEnv.getfenv = function(f)
		f = f or 1
		CheckVarTypes(f, "number", "function")
		local t = type(f)
		local env = nil
		if t == "function" then
			env = getfenv(f)
		elseif t == "number" then
			if f == 0 then
				return tSysEnv
			elseif f < 0 then
				error("Bad argument: level must be non-negative.")
			else
				f = f + 1
				env = getfenv(f)
			end
		end
		return env
	end
	tSysEnv.setfenv = function(f, e)
		CheckVarTypes(f, "number", "function")
		CheckVarType(e, "table")
		local t = type(f)
		if t == "number" then
			if f == 0 then
				error("Cannot change environment of given object.")
			elseif f < 0 then
				error("Bad argument: level must be non-negative.")
			else
				f = f + 1
			end
		end
		return setfenv(f, e)
	end
	
	-- load functions
	tSysEnv.load = function(f, n)
		return load(f, n, tSysEnv)
	end
	tSysEnv.loadstring = function(s, n)
		return loadstring(s, n, tSysEnv)
	end
	tSysEnv.loadfile = function(f)
		return loadfile(f, tSysEnv)
	end
	tSysEnv.dofile = function(f)
		return dofile(f, tSysEnv)
	end
	
	-- to access shared environment
	setmetatable(tSysEnv, { __index = tSharedEnv })
end

--[[
- InitSharedEnv (function)
	* initializes the shared environment with all the global variables and functions
	* loaded variables and functions:
		- every variable and function in the "copied" table
		- getfenv/setfenv: modified version of the functions to protect the global environment
		- load/loadstring: modified version of the functions that sets the users environment for the loaded functions
--]]
local function InitSharedEnv()
	-- variables and functions to copy
	local copied = { "assert", "error", "getmetatable", "ipairs", "next", "pairs", "pcall",
			      "select", "setmetatable", "tonumber", "tostring", "type", "unpack", "_VERSION",
			      "xpcall", "__inext", "math", "string", "table" }
	
	-- Global functions
	for _,val in ipairs(copied) do
		tSharedEnv[val] = _G[val]
	end
	
	-- env functions
	tSharedEnv.getfenv = function(f)
		f = f or 1
		CheckVarTypes(f, "function", "number")
		local t = type(f)
		local env = nil
		if t == "function" then
			env = getfenv(f)
		elseif t == "number" then
			if f == 0 then
				return tSharedEnv
			elseif f < 0 then
				error("Bad argument: level must be non-negative.")
			else
				f = f + 1
				env = getfenv(f)
			end
		end
		return env
	end
	tSharedEnv.setfenv = function(f, e)
		CheckVarTypes(f, "function", "number")
		CheckVarType(e, "table")
		local t = type(f)
		if t == "number" then
			if f == 0 then
				error("Cannot change environment of given object.")
			elseif f < 0 then
				error("Bad argument: level must be non-negative.")
			else
				f = f + 1
			end
		end
		return setfenv(f, e)
	end
	
	-- load functions
	tSharedEnv.load = function(f, n)
		return load(f, n, tSharedEnv)
	end
	tSharedEnv.loadstring = function(s, n)
		return loadstring(s, n, tSharedEnv)
	end
end

local tSysLibs = {}

--[[
- LoadSystemLib (function)
	* loads a system library file to the shared environment
	* parameters:
		- sPath: the path to the library file (string)
--]]
local function LoadSystemLib(sPath)
	local sName = fs.getName(sPath)
	local tLibEnv = {}
	setmetatable(tLibEnv, { __index = tSysEnv })
	local fnLib, err = loadfile(sPath, tLibEnv)
	if fnLib then
		fnLib()
	else
		return false, err
	end
	local tLib = {}
	for k, v in pairs(tLibEnv) do
		tLib[k] =  v
	end
	protect(tLib)
	bProtected = false
	tSharedEnv[sName] = tLib
	bProtected = true
	tSysLibs[sName] = true
	return true
end

--[[
- UnloadSystemLib (function)
	* removes a library from the system environment
	* parameters:
		- sName: the name of the library to remove (string)
--]]
local function UnloadSystemLib(sName)
	if tSysLibs[sName] then
		bProtected = false
		tSharedEnv[sName] = nil
		bProtected = true
		tSysLibs[sName] = nil
		return true
	end
	return false
end

local tHandlers = {}

local function AddEventHandler(sEvt, fHandler)
	if not tHandlers[sEvt] then
		tHandlers[sEvt] = {}
	end
	table.insert(tHandlers[sEvt], fHandler)
end

--[[
- HandleEvent (function)
	* handles incoming events, passing them to the event handlers
	* return values:
		- boolean indicating if the event was handled (boolean)
	* parameters:
		- evt: the event type (string)
		- ...: event arguments
--]]
local function HandleEvent(sEvt, ...)
	local bHandled = false
	if sEvt and tHandlers[sEvt] then
		for _,handler in ipairs(tHandlers[sEvt]) do
			if handler(...) then
				bHandled = true
			end
		end
	end
	return bHandled
end

--[[
- CheckFilter (function)
	* checks if the given event is in the given filters list
	* return values:
		- boolean indicating if the event is in the filters list (boolean)
	* parameters:
		- sEvt: the event type (string)
		- tFilter: filters list to check (table)
--]]
local function CheckFilter(sEvt, tFilter)
	return sEvt == nil or tFilter == nil or #tFilter == 0 or table.contains(tFilter, sEvt)
end

-- Process functions

local tRunningQueue = {}
local tReadyQueue = {}
local nPID = 0
local nRunningProcess = 0
local nRunningThread = 0

local function CreateProcess(sName)
	nPID = nPID + 1
	local proc = {}
	proc.id = nPID
	proc.name = sName
	proc.tid = 0
	proc.runningThreads = {}
	proc.readyThreads = {}
	proc.filters = {}
	proc.env = {}
	proc.env._G = proc.env
	setmetatable(proc.env, { __index = tSharedEnv })
	table.insert(tReadyQueue, proc)
	return nPID
end

local function KillProcess(pid)
	for i, proc in ipairs(tRunningQueue) do
		if proc.id == pid then
			table.remove(tRunningQueue, i)
			return true
		end
	end
	for i, proc in ipairs(tReadyQueue) do
		if proc.id == pid then
			table.remove(tReadyQueue, i)
			return true
		end
	end
	return false
end

local function GetProcess(pid)
	for _,proc in ipairs(tRunningQueue) do
		if proc.id == pid then
			return proc
		end
	end
	for _,proc in ipairs(tReadyQueue) do
		if proc.id == pid then
			return proc
		end
	end
	return nil
end

local function GetCurrentProcess()
	return nRunningProcess
end

local function AddThread(proc, thread)
	proc.tid = proc.tid + 1
	table.insert(proc.readyThreads, thread)
	return proc.tid
end

local function ProcessCount()
	return #tReadyQueue + #tRunningQueue
end

local function ThreadCount(proc)
	return #proc.readyThreads + #proc.runningThreads
end

local function UpdateThreads(proc)
	for i, v in ipairs(proc.readyThreads) do
		table.insert(proc.runningThreads, v)
		table.remove(proc.readyThreads, i)
	end
end

local function UpdateProcs()
	for i, v in ipairs(tReadyQueue) do
		table.insert(tRunningQueue, v)
		table.remove(tReadyQueue, i)
		UpdateThreads(v)
	end
end

-- Thread functions

local function CreateThread(pid, func)
	local proc = GetProcess(pid)
	if proc then
		setfenv(func, proc.env)
		local co = coroutine.create(func)
		if co then
			local thread = {}
			thread.id = AddThread(proc, thread)
			thread.routine = co
			return thread.id
		end
	end
	return nil
end

local function KillThread(pid, tid)
	local proc = GetProcess(pid)
	if proc then
		for i, thread in ipairs(proc.runningThreads) do
			if thread.id == tid then
				table.remove(proc.runningThreads, i)
				return true
			end
		end
		for i, thread in ipairs(proc.readyThreads) do
			if thread.id == tid then
				table.remove(proc.readyThreads, i)
				return true
			end
		end
	end
	return false
end

local function GetCurrentThread()
	return nRunningThread
end

-- Main functions

local function CreateMainProc()
	local pid = CreateProcess("Main")
	local func, err = loadfile(fs.combine(sOsDir, "startup"))
	if not func then
		return nil, err
	end
	local tid = CreateThread(pid, func)
	return pid, tid
end

--[[
- Start (function)
	* startup function, loads and executes the startup file in a coroutine
	* return values:
		- boolean indicating if the execution were successful (boolean)
		- the value returned by the coroutine (an error message in case of error)
--]]
local function Start()
	local mainPID, mainTID = CreateMainProc()
	if not mainPID then
		return false, mainTID
	end
	local tStatus = {}
	local tEvt = {}
	while not bTerminate and ProcessCount() > 0 do
		UpdateProcs()
		if not HandleEvent(unpack(tEvt)) then
			for _,proc in ipairs(tRunningQueue) do
				nRunningProcess = proc.id
				for _,thread in ipairs(proc.runningThreads) do
					if CheckFilter(tEvt[1], proc.filters[thread.id]) then
						nRunningThread = thread.id
						tStatus = { coroutine.resume(thread.routine, unpack(tEvt)) }
						if coroutine.status(thread.routine) == "dead" then
							KillThread(proc.id, thread.id)
							if thread.id == mainTID then
								bTerminate = true
							end
						else
							proc.filters[thread.id] = { unpack(tStatus, 2) }
						end
					end
				end
				if ThreadCount(proc) == 0 then
					KillProcess(proc.id)
				end
			end
		end
		if not bTerminate then
			tEvt = { coroutine.yield() }
		end
	end
	return unpack(tStatus)
end

-- System API

--[[
- sys (table)
	* sys API table
--]]
sys = {}

--[[
- sys.version (function)
	* gets the version string
	* return values:
		- version string (string)
--]]
function sys.version()
	return sVersion
end

--[[
- sys.versionNum (function)
	* gets the version number
	* return values:
		- version number (number)
--]]
function sys.versionNum()
	return nVersion
end

function sys.osDir()
	return sOsDir
end

--[[
- sys.shutdown (function)
	* sets the termination flag on to shutdown the computer and stops execution
--]]
function sys.shutdown()
	bTerminate = true
	while true do
		coroutine.yield()
	end
end

--[[
- sys.reboot (function)
	* sets the termination and reboot flags on to reboot the computer and stops execution
--]]
function sys.reboot()
	bTerminate = true
	bReboot = true
	while true do
		coroutine.yield()
	end
end

--[[
- tSharedLibs (table)
	* contains the names of every shared libs
--]]
local tSharedLibs = {}

--[[
- sys.loadSharedLib (function)
	* loads a library to the shared environment
	* return values:
		- boolean indicating if the library was loaded (boolean)
		- string containing the error message, if any (string, nil)
	* parameters:
		- sLib: the library code to load (string)
		- sName: the library name (string)
--]]
function sys.loadSharedLib(sLib, sName)
	local tLibEnv = {}
	setmetatable(tLibEnv, { __index = tSharedEnv })
	local fnLib, err = loadstring(sLib, sName, tLibEnv)
	if fnLib then
		fnLib()
	else
		return false, err
	end
	local tLib = {}
	for k,v in pairs(tLibEnv) do
		tLib[k] =  v
	end
	protect(tLib)
	bProtected = false
	tSharedEnv[sName] = tLib
	bProtected = true
	tSharedLibs[sName] = true
	return true
end

--[[
- sys.unloadSharedLib (function)
	* unloads a library from the shared environment
	* return values:
		- boolean indicating if the lib was unloaded (boolean)
		- string containing the error message, if any (string, nil)
	* parameters:
		- sName: the name of the lib to unload (string)
--]]
function sys.unloadSharedLib(sName)
	if tSharedLibs[sName] then
		bProtected = false
		tSharedEnv[sName] = nil
		bProtected = true
		tSharedLibs[sName] = nil
		return true
	end
	return false, "No such library "..sName
end

--[[
- sys.unloadSharedLibs (function)
	* unloads every shared libs
--]]
function sys.unloadSharedLibs()
	bProtected = false
	for name,_ in pairs(tSharedLibs) do
		bProtected = false
		tSharedEnv[sName] = nil
		bProtected = true
		tSharedLibs[sName] = nil
	end
	bProtected = true
end

function sys.listLibs(bAll)
	local tList = {}
	for sLib,_ in pairs(tSharedLibs) do
		table.insert(tList, sLib)
	end
	if bAll then
		for sLib,_ in pairs(tSysLibs) do
			table.insert(tList, sLib)
		end
	end
	return tList
end

function sys.addEventHandler(sEvt, fHandler)
	return AddEventHandler(sEvt, fHandler)
end

function sys.createProcess(sName)
	return CreateProcess(sName)
end

function sys.killProcess(pid)
	return KillProcess(pid)
end

function sys.getProcesses()
	local t = {}
	for _,proc in ipairs(tReadyQueue) do
		local p = {}
		p.id = proc.id
		p.name = proc.name
		table.insert(t, p)
	end
	for _,proc in ipairs(tRunningQueue) do
		local p = {}
		p.id = proc.id
		p.name = proc.name
		table.insert(t, p)
	end
	return t
end

function sys.processCount()
	return ProcessCount()
end

function sys.runningProcess()
	return GetCurrentProcess()
end

function sys.createThread(pid, func)
	return CreateThread(pid, func)
end

function sys.killThread(pid, tid)
	return KillThread(pid, tid)
end

function sys.getThreads(pid)
	local proc = GetProcess(pid)
	if proc then
		local t = {}
		for _,thread in ipairs(proc.readyThreads) do
			table.insert(t, thread.id)
		end
		for _,thread in ipairs(proc.runningThreads) do
			table.insert(t, thread.id)
		end
		return t
	end
	return nil
end

function sys.threadCount(pid)
	local proc = GetProcess(pid)
	if proc then
		return ThreadCount(proc)
	end
	return nil
end

function sys.runningThread()
	return GetCurrentThread()
end

-- Initialize Environments

-- Initialize system environment
InitSysEnv()

-- protect every table inside the system environment
for _,v in pairs(tSysEnv) do
	if type(v) == "table" then
		protect(v)
	end
end

-- Load system Libs
local sLibsDir = fs.combine(sOsDir, "system/libs")
local tLibs = fs.list(sLibsDir)
for _,sName in ipairs(tLibs) do
	local sFile = fs.combine(sLibsDir, sName)
	if not fs.isDir(sFile) then
		LoadSystemLib(sFile)
	end
end

-- Initialize the shared environment
InitSharedEnv()

-- protect every table inside the shared environment
for _,v in pairs(tSharedEnv) do
	if type(v) == "table" then
		protect(v)
	end
end

-- OS loaded, start running

-- Start execution
local ok, err = Start()
if not ok then
	error(err)
end

-- reboot if needed
if bReboot then
	os.reboot()
	while true do
		coroutine.yield()
	end
end