-- MysticOS GUI API

--[[
TODO:
	.controls:
		+ checkbox
		+ text & line edit
		+ focusable property
	.Control:
		+ write & print functions
		+ common drawing functions
	* fix menus
--]]

-- Helper functions

local function checkBounds(x, y, w, h, px, py)
	return px >= x and px < x + w and py >= y and py < y + h
end

local function checkControlBounds(ctrl, x, y)
	return checkBounds(ctrl.x, ctrl.y, ctrl.width, ctrl.height, x, y)
end

local function newClass(parent)
	return setmetatable({}, { __index = parent })
end

local function newObj(tbl, class)
	return setmetatable(tbl, { __index = class })
end

-- Control

Control = {}

function Control:getPos()
	return self.x, self.y
end

function Control:setPos(x, y)
	self.x = x
	self.y = y
end

function Control:getX()
	return self.x
end

function Control:setX(x)
	self.x = x
end

function Control:getY()
	return self.y
end

function Control:setY(y)
	self.y = y
end

function Control:getSize()
	return self.width, self.height
end

function Control:getWidth()
	return self.width
end

function Control:getHeight()
	return self.height
end

function Control:resize(w, h)
	self.width = w
	self.height = h
end

function Control:setBackgroundColor(c)
	self.bgColor = c
end
Control.setBackgroundColour = Control.setBackgroundColor

function Control:getBackgroundColor()
	return self.bgColor
end
Control.getBackgroundColour = Control.getBackgroundColor

function Control:setTextColor(c)
	self.txtColor = c
end
Control.setTextColour = Control.setTextColor

function Control:getTextColor()
	return self.txtColor
end
Control.getTextColour = Control.getTextColor

function Control:write(target, txt)
	-- TODO --
end

function Control:print(target, ...)
	-- TODO --
end

function Control:clear(target)
	local line = string.rep(" ", self.width)
	for y = 0, self.height - 1 do
		target.write(line, self.x, self.y + y)
	end
end

function Control:clearLine(target, y)
	target.write(string.rep(" ", self.width), self.x, self.y + y - 1)
end

function Control:drawLine(target, x1, y1, x2, y2)
	-- TODO --
end

function Control:drawRect(target, x, y, w, h)
	local line = string.rep(" ", w)
	for i = 0, h - 1 do
		target.write(line, x, y + i)
	end
end

function Control:draw(target)
	target.setBackgroundColor(self.bgColor)
	target.setTextColor(self.txtColor)
	self:clear(target)
end

function control(x, y, w, h)
	local ctrl = {}
	ctrl.x = x
	ctrl.y = y
	ctrl.width = w
	ctrl.height = h
	ctrl.bgColor = colors.black
	ctrl.txtColor = colors.white
	return newObj(ctrl, Control)
end

-- Container

Container = newClass(Control)

function Container:addChild(child)
	if child.parent then
		child.parent:removeChild(child)
	end
	child.parent = self
	table.insert(self.childs, 1, child)
end

function Container:removeChild(child)
	for i = 1, #self.childs do
		if self.childs[i] == child then
			table.remove(self.childs, i)
			child.parent = nil
			break
		end
	end
end

function Container:setFocus(child)
	for i = 1, #self.childs do
		if self.childs[i] == child then
			table.move(self.childs, i, 1)
			break
		end
	end
end

function Container:handleEvent(evt, ...)
	if evt == "mouse_click" then
		return self:onMouseClick(...)
	elseif evt == "mouse_drag" then
		return self:onMouseDrag(...)
	elseif evt == "mouse_scroll" then
		return self:onMouseScroll(...)
	elseif evt == "key" then
		return self:onKeyDown(...)
	elseif evt == "char" then
		return self:onChar(...)
	else
		for i = 1, #self.childs do
			local child = self.childs[i]
			if child.handleEvent and child:handleEvent(evt, ...) then
				return true
			end
		end
	end
	return false
end

function Container:onMouseClick(btn, x, y)
	for i = 1, #self.childs do
		local child = self.childs[i]
		if checkControlBounds(child, x, y) then
			self:setFocus(child)
			if child.onMouseClick then
				child:onMouseClick(btn, (x - child.x) + 1, (y - child.y) + 1)
			end
			return true
		end
	end
	return false
end

function Container:onMouseDrag(btn, x, y)
	for i = 1, #self.childs do
		local child = self.childs[i]
		if checkControlBounds(child, x, y) then
			self:setFocus(child)
			if child.onMouseDrag then
				child:onMouseDrag(btn, (x - child.x) + 1, (y - child.y) + 1)
			end
			return true
		end
	end
	return false
end

function Container:onMouseScroll(dir, x, y)
	for i = 1, #self.childs do
		local child = self.childs[i]
		if checkControlBounds(child, x, y) then
			if child.onMouseScroll then
				child:onMouseScroll(dir)
			end
			return true
		end
	end
	return false
end

function Container:onKeyDown(key)
	local child = self.childs[1]
	if child and child.onKeyDown then
		child:onKeyDown(key)
		return true
	end
	return false
end

function Container:onChar(char)
	local child = self.childs[1]
	if child and child.onChar then
		child:onChar(char)
		return true
	end
	return false
end

function Container:resize(w, h)
	Control.resize(self, w, h)
	self.buffer:resize(w, h)
end

function Container:draw(target)
	self.buffer:setBackgroundColor(self.bgColor)
	self.buffer:clear()
	for i = #self.childs, 1, -1 do
		self.childs[i]:draw(self.drawTarget)
	end
	self.buffer:render(target)
end

function container(x, y, w, h)
	local c = control(x, y, w, h)
	c.childs = {}
	local buff = screenbuffer.new(w, h)
	c.buffer = buff
	c.drawTarget = {
		drawBuffer = function(buff, x, y, w, h) buff:drawBuffer(buff, x, y, w, h) end,
		drawImage = function(img, x, y, w, h, ox, oy) buff:drawImage(img, x, y, w, h, ox, oy) end,
		write = function(txt, x, y) buff:write(txt, x, y) end,
		read = function(len, x, y) return buff:read(len, x, y) end,
		clear = function(c) buff:clear(c) end,
		clearLine = function(y) buff:clearLine(y) end,
		getSize = function() return buff:getSize() end,
		getWidth = function() return buff:getWidth() end,
		getHeight = function() return buff:getHeight() end,
		getCursorPos = function() return buff:getCursorPos() end,
		setCursorPos = function(x, y) buff:setCursorPos(x, y) end,
		setCursorBlink = function(b) buff:setCursorBlink(b) end,
		getCursorBlink = function() return buff:getCursorBlink() end,
		scroll = function(n) buff:scroll(n) end,
		setTextColor = function(c, x, y) buff:setTextColor(c, x, y) end,
		setTextColour = function(c, x, y) buff:setTextColor(c, x, y) end,
		getTextColor = function(x, y) return buff:getTextColor(x, y) end,
		getTextColour = function(x, y) return buff:getTextColor(x, y) end,
		setBackgroundColor = function(c, x, y) buff:setBackgroundColor(c, x, y) end,
		setBackgroundColour = function(c, x, y) buff:setBackgroundColor(c, x, y) end,
		getBackgroundColor = function(x, y) return buff:getBackgroundColor(x, y) end,
		getBackgroundColour = function(x, y) return buff:getBackgroundColor(x, y) end,
		setChar = function(c, x, y) buff:setChar(c, x, y) end,
		getChar = function(x, y) return buff:getChar(x, y) end,
		drawChar = function(c, x, y) buff:drawChar(c, x, y) end,
		snapshot = function() return buff:snapshot() end
	}
	return newObj(c, Container)
end

-- Frame

Frame = newClass(Container)

function Frame:run(defaultHandler, renderTarget)
	renderTarget = renderTarget or display
	while not self.bExit do
		self:draw(renderTarget)
		local tEvt = { os.pullEvent() }
		if not self:handleEvent(unpack(tEvt)) and defaultHandler then
			defaultHandler(unpack(tEvt))
		end
	end
end

function Frame:close()
	self.bExit = true
end
Frame.exit = Frame.close

function frame(x, y, w, h)
	local f = container(x, y, w, h)
	f.bExit = false
	return newObj(f, Frame)
end

-- Label

Label = newClass(Control)

function Label:draw(target)
	Control.draw(self, target)
	--target.setCursorPos(self.x, self.y)
	--self:write(target, self.text)
	target.write(self.text, self.x, self.y)
end

function Label:setText(txt)
	self.text = txt
end

function label(x, y, w, h, txt)
	local lbl = control(x, y, w, h)
	lbl.text = txt or ""
	return newObj(lbl, Label)
end

-- Button

Button = newClass(Control)

function Button:draw(target)
	Control.draw(self, target)
	local len = math.min(#self.text, self.width)
	local txt = string.sub(self.text, 1, len)
	local x = math.ceil((self.width - len) / 2)
	local y = math.ceil(self.height / 2) - 1
	target.write(txt, self.x + x, self.y + y)
end

function Button:setText(txt)
	self.text = txt
end

function Button:getText()
	return self.text
end

function Button:onMouseClick(btn, x, y)
	if btn == 1 and self.callback then
		self.callback()
	end
end

function button(x, y, w, h, txt, callback)
	local btn = control(x, y, w, h)
	btn.text = txt or ""
	btn.callback = callback
	return newObj(btn, Button)
end

-- Image Button

ImageButton = newClass(Control)

function ImageButton:draw(target)
	if self.image then
		local w = math.min(self.image:getWidth(), self.width)
		local h = math.min(self.image:getHeight(), self.height)
		target.drawImage(self.image, self.x, self.y, w, h)
	end
end

function ImageButton:setImage(img)
	self.image = img
end

function ImageButton:onMouseClick(btn, x, y)
	if btn == 1 and self.callback then
		self.callback()
	end
end

function imageButton(x, y, w, h, img, callback)
	local btn = control(x, y, w, h)
	if type(img) == "string" then
		btn.image = imageio.load(img)
	else
		btn.image = img
	end
	btn.callback = callback
	return newObj(btn, ImageButton)
end

-- List

List = newClass(Control)

function List:draw(target)
	for i = 1, math.min(#self.list, self.height) do
		if i + self.scroll == self.selected then
			target.setBackgroundColor(self.txtColor)
			target.setTextColor(self.bgColor)
		else
			target.setBackgroundColor(self.bgColor)
			target.setTextColor(self.txtColor)
		end
		self:clearLine(target, i)
		target.write(string.sub(tostring(self.list[i + self.scroll]), 1, self.width), self.x, self.y + i - 1)
	end
end

function List:getList()
	return self.list
end

function List:setList(l)
	self.list = l
end

function List:scroll(n)
	if self.list then
		self.scroll = math.max(math.min(self.scroll + n, #self.list - self:getHeight()), 0)
	end
end

function List:setSelected(n)
	if self.list then
		if n ~= self.selected and n > 0 and n <= #self.list then
			self.selected = n
			if self.selected - self.scroll > self:getHeight() then
				self.scroll = self.selected - self:getHeight()
			elseif self.selected - self.scroll < 1 then
				self.scroll = self.selected - 1
			end
			if self.onSelectionChanged then
				self.onSelectionChanged()
			end
		end
	end
end

function List:getSelected()
	return self.list[self.selected]
end

function List:next()
	if self.selected < #self.list then
		self:setSelected(self.selected + 1)
	else
		self:setSelected(1)
	end
end

function List:prev()
	if self.selected > 1 then
		self:setSelected(self.selected - 1)
	else
		self:setSelected(#self.list)
	end
end

function List:onMouseClick(btn, x, y)
	if self.list then
		y = y + self.scroll
		if btn == 1 and y <= #self.list then
			if y == nSelected then
				-- TODO: activate callback?
			else
				self:setSelected(y)
			end
		end
	end
end

function List:onMouseScroll(dir)
	self:scroll(dir)
end

function List:onKeyDown(key)
	if key == keys.down then
		self:next()
	elseif key == keys.up then
		self:prev()
	elseif key == keys["end"] then
		self:setSelected(#self.list)
	elseif key == keys.home then
		self:setSelected(1)
	elseif key == keys.enter then
		-- TODO: activate callback?
	end
end

function list(x, y, w, h, l, callback)
	local tList = control(x, y, w, h)
	tList.list = l or {}
	tList.scroll = 0
	tList.selected = 1
	tList.onSelectionChanged = callback
	return newObj(tList, List)
end

-- Bar Control

Bar = newClass(Control)

function Bar:draw(target)
	Control.draw(self, target)
	target.setBackgroundColor(self.fillColor)
	local w = math.floor(self.width * self.fill)
	target.write(string.rep(" ", w), self.x, self.y)
end

function Bar:getFillColor()
	return self.fillColor
end

function Bar:setFillColor(c)
	self.fillColor = c
end

function Bar:getFill()
	return self.fill
end

function Bar:setFill(n)
	self.fill = math.max(math.min(n, 1), 0)
end

function bar(x, y, w)
	local bar = control(x, y, w, 1)
	bar.fillColor = colors.green
	bar.fill = 0
	return newObj(bar, Bar)
end

-- Slider Bar Control

SliderBar = newClass(Bar)

function SliderBar:isActive()
	return self.active
end

function SliderBar:setActive(b)
	self.active = b
end

function SliderBar:onMouseClick(btn, x, y)
	if self.active and btn == 1 then
		self.fill = x / self:getWidth()
		if self.callback then
			self.callback(self.fill)
		end
	end
end
SliderBar.onMouseDrag = SliderBar.onMouseClick

function sliderBar(x, y, w, callback)
	local sbar = bar(x, y, w)
	sbar.active = true
	sbar.onClick = callback
	return newObj(sbar, SliderBar)
end

-- Message Box

MessageBox = newClass(Control)

function MessageBox:draw(target)
	-- TODO --
	Control.draw(self, target)
	target.write(self.title, self.x + math.floor((self.width - #self.title) / 2), self.y)
	target.setCursorPos(self.x, self.y + 1)
	self:print(target, self.msg)
end

function messageBox(x, y, w, h, title, msg)
	local msgbox = control(x, y, w, h)
	msgbox.title = tostring(title)
	msgbox.msg = tostring(msg)
	return newObj(msgbox, MessageBox)
end

-- Canvas

Canvas = newClass(Control)

function Canvas:draw(target)
	Control.draw(self, target)
	target.drawImage(self.img, self.x, self.y, self.width, self.height, self.ox, self.oy)
end

function Canvas:setOffset(ox, oy)
	self.ox = ox
	self.oy = oy
end

function Canvas:getImage()
	return self.img
end

function canvas(x, y, w, h, imgW, imgH)
	local c = control(x, y, w, h)
	c.img = image.new(imgW, imgH)
	c.ox = 0
	c.oy = 0
	c:setBackgroundColor(colors.lightGray)
	c.img:setBackgroundColor(colors.white)
	c.img:clear()
	return newObj(c, Canvas)
end

-- MenuItem

MenuItem = {}

function MenuItem:getName()
	return self.name
end

function MenuItem:setName(name)
	self.name = name
end

function MenuItem:getAction()
	return self.action
end

function MenuItem:setAction(action)
	self.action = action
end

function menuItem(name, action)
	local item = {}
	item.name = name
	item.action = action
	return newObj(item, MenuItem)
end

-- Menu

Menu = {}

function Menu:draw(target, x, y)
	for i = 1, #self.items do
		-- TODO: clear line
		target.write(self.items[i]:getName(), x, y + i - 1)
	end
end

function Menu:getName()
	return self.name
end

function Menu:setName(name)
	self.name = name
end

function Menu:getItems()
	return self.items
end

function Menu:addMenuItem(item)
	self.items[#self.items + 1] = item
end

function Menu:removeMenuItem(item)
	for i = 1, #self.items do
		if self.items[i] == item then
			table.remove(self.items, i)
		end
	end
end

function Menu:isOpen()
	return self.bOpen
end

function Menu:open()
	self.bOpen = true
end

function Menu:close()
	self.bOpen = false
end

function menu(name)
	local m = {}
	m.name = name
	m.items = {}
	m.bOpen = false
	return newObj(m, Menu)
end

-- Menu Bar

MenuBar = newClass(Control)

function MenuBar:draw(target)
	Control.draw(self, target)
	target.setBackgroundColor(self.menuBgColor)
	local x = 0
	for i = 1, #self.menus do
		local m = self.menus[i]
		local name = m:getName()
		target.write(m:getName(), self.x + x, self.y)
		if m:isOpen() then
			m:draw(target, self.x + x, self.y + 1)
		end
		x = x + #name
	end
end

function MenuBar:addMenu(m)
	self.menus[#self.menus + 1] = m
end

function MenuBar:removeMenu(m)
	for i = 1, #self.menus do
		if self.menus[i] == m then
			table.remove(self.menus, i)
			if self.menus[i] == self.curMenu then
				self.curMenu:close()
				self.curMenu = nil
			end
		end
	end
end

function MenuBar:onMouseClick(btn, x, y)
	if btn == 1 then
		if y == 1 then
			local mx = 1
			for i = 1, #self.menus do
				local w = #self.menus[i]:getName()
				if x >= mx and x < mx + w then
					if self.menus[i] == self.curMenu then
						self.curMenu:close()
						self.curMenu = nil
					else
						if self.curMenu then
							self.curMenu:close()
						end
						self.menus[i]:open()
						self.curMenu = self.menus[i]
					end
					break
				end
				mx = mx + w
			end
		end
	end
end

function menuBar(x, y, w, bgColor)
	local bar = control(x, y, w, 1)
	bar.menus = {}
	bar.menuBgColor = bgColor or colors.black
	return newObj(bar, MenuBar)
end