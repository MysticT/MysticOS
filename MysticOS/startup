-- MysticOS Startup

--[[
TODO:
	+ error handling (show error message)
	+ per-process timers?
--]]

-- Environments

local tMainEnv = {}
local tBackgroundEnv = {}

-- OS API

local nativeOS = os
os = {}

function os.version()
	return system.version()
end

function os.checkVersion(ver, minor, build)
	return system.checkVersion(ver, minor, build)
end

function os.computerID()
	return nativeOS.computerID()
end
os.getComputerID = os.computerID

function os.getComputerLabel()
	return nativeOS.getComputerLabel()
end

function os.pullEventRaw(...)
	return coroutine.yield(...)
end

function os.pullEvent(...)
	return coroutine.yield(...)
end

function os.queueEvent(...)
	return nativeOS.queueEvent(...)
end

function os.clock()
	return nativeOS.clock()
end

function os.startTimer(nTime)
	return nativeOS.startTimer(nTime)
end

function os.sleep(nTime)
	local timer = os.startTimer(nTime)
	while true do
		local evt, arg = os.pullEvent("timer")
		if arg == timer then
			break
		end
	end
end

function os.time()
	return nativeOS.time()
end

function os.day()
	return nativeOS.day()
end

function os.setAlarm(nTime)
	return nativeOS.setAlarm(nTime)
end

function os.shutdown()
	system.shutdown()
	while true do
		coroutine.yield()
	end
end

function os.reboot()
	system.shutdown()
	nativeOS.reboot()
	while true do
		coroutine.yield()
	end
end

function os.loadAPI(path, name)
	local env = getfenv(2)
	local tEnv = {}
	setmetatable(tEnv, { __index = env })
	local fnAPI, err = loadfile(path, tEnv)
	if not fnAPI then
		return nil, err
	end
	local ok, api = pcall(fnAPI)
	if not ok then
		return nil, api
	end
	if not api or type(api) ~= "table" then
		api = {}
		for k, v in pairs(tEnv) do
			api[k] = v
		end
	end
	name = name or fs.getName(path, true)
	env[name] = api
	return api, name
end

function os.unloadAPI(name)
	local env = getfenv(2)
	if env[name] then
		env[name] = nil
	end
end

local bSwitchApp = false
local sAppName
local tAppArgs

function os.run(path, ...)
	local ok, name = app.run(path, tMainEnv)
	if not ok then
		return false, name
	end
	-- TODO: check if there's another app waiting to start
	bSwitchApp = true
	sAppName = name
	tAppArgs = { ... }
	return true
end

function os.runOnBackground(path)
	return app.runOnBackground(path, tBackgroundEnv)
end

function os.killApp(name)
	return app.kill(name)
end

function os.switchApp(name)
	if app.isValid(name) then
		bSwitchApp = true
		sAppName = name
		tAppArgs = {}
		return true
	end
	return false
end

function os.runningApps()
	return app.list()
end

function os.addNotification(title, msg)
	return notifications.add(title, msg)
end

function os.removeNotification(id)
	notifications.remove(id)
end

function os.getNotification(id)
	return notifications.get(id)
end

function os.listNotifications()
	return notifications.list()
end

-- Global functions

function sleep(nTime)
	os.sleep(nTime)
end

function write(sText)
	sText = tostring(sText)
	local nLines = 0
	local w, h = term.getSize()
	if w < 1 or h < 1 then
		return 0
	end
	local x, y = term.getCursorPos()
	local function newline()
		if y + 1 <= h then
			term.setCursorPos(1, y + 1)
		else
			term.scroll(1)
			term.setCursorPos(1, h)
		end
		x, y = term.getCursorPos()
		nLines = nLines + 1
	end
	while #sText > 0 do
		local space = string.match(sText, "^([ \t]+)")
		if space then
			term.write(space)
			x, y = term.getCursorPos()
			sText = string.sub(sText, #space + 1)
		end
		while string.at(sText, 1) == "\n" do
			newline()
			sText = string.sub(sText, 2)
		end
		if #sText > 0 then
			local txt = string.match(sText, "^[^ \t\n]+")
			if txt then
				sText = string.sub(sText, #txt + 1)
				if #txt > w then
					while #txt > 0 do
						if x > w then
							newline()
						end
						term.write(txt)
						txt = string.sub(txt, (w - x) + 2)
						x, y = term.getCursorPos()
					end
				else
					if #txt > w - x then
						newline()
					end
					term.write(txt)
					x, y = term.getCursorPos()
				end
			end
		end
	end
	return nLines
end

function print(...)
	local nLines = 0
	for i = 1, #arg do
		nLines = nLines + write(tostring(arg[i]))
	end
	nLines = nLines + write("\n", true)
	return nLines
end

function printError(...)
	if term.isColor() then
		term.setTextColor(colors.red)
	end
	print(...)
	term.setTextColor(colors.white)
end

function read(sReplaceChar, tHistory, nMax)
	term.setCursorBlink(true)
	local sLine = ""
	local nHistoryPos = nil
	local nPos = 0
	if sReplaceChar then
		sReplaceChar = string.at(sReplaceChar, 1)
	end
	local w, h = term.getSize()
	local sx, sy = term.getCursorPos()
	local function redraw()
		local nScroll = 0
		if sx + nPos >= w then
			nScroll = (sx + nPos) - w
		end
		term.setCursorPos(sx, sy)
		term.write(string.rep(" ", w - sx + 1))
		term.setCursorPos(sx, sy)
		if sReplaceChar then
			term.write(string.rep(sReplaceChar, #sLine - nScroll))
		else
			term.write(string.sub(sLine, nScroll + 1 ))
		end
		term.setCursorPos(sx + nPos - nScroll, sy)
	end
	while true do
		local evt, arg = os.pullEvent("char", "key")
		if evt == "char" then
			if not nMax or #sLine < nMax then
				sLine = string.sub(sLine, 1, nPos)..arg..string.sub(sLine, nPos + 1)
				nPos = nPos + 1
				redraw()
			end
		elseif evt == "key" then
			if arg == keys.enter then
				break
			elseif arg == keys.left then
				if nPos > 0 then
					nPos = nPos - 1
					redraw()
				end
			elseif arg == keys.right then
				if nPos < #sLine then
					nPos = nPos + 1
					redraw()
				end
			elseif arg == keys.up or arg == keys.down then
				if tHistory then
					if arg == keys.up then
						if nHistoryPos == nil then
							if #tHistory > 0 then
								nHistoryPos = #tHistory
							end
						elseif nHistoryPos > 1 then
							nHistoryPos = nHistoryPos - 1
						end
					else
						if nHistoryPos == #tHistory then
							nHistoryPos = nil
						elseif nHistoryPos ~= nil then
							nHistoryPos = nHistoryPos + 1
						end						
					end
					if nHistoryPos then
						sLine = tHistory[nHistoryPos]
						nPos = #sLine
					else
						sLine = ""
						nPos = 0
					end
					redraw()
				end
			elseif arg == keys.backspace then
				if nPos > 0 then
					sLine = string.sub(sLine, 1, nPos - 1)..string.sub(sLine, nPos + 1)
					nPos = nPos - 1
					redraw()
				end
			elseif arg == keys.delete then
				sLine = string.sub(sLine, 1, nPos)..string.sub(sLine, nPos + 2)
				redraw()
			elseif arg == keys.home then
				nPos = 0
				redraw()
			elseif arg == keys["end"] then
				nPos = #sLine
				redraw()
			end
		end
	end
	term.setCursorBlink(false)
	term.setCursorPos(w + 1, sy)
	print()
	return sLine
end

-- Initialize Environments

do
	-- Load APIs
	print("Loading APIs...")
	local sApisPath = "/MysticOS/apis"
	local apis = fs.list(sApisPath)
	table.sort(apis)
	for i = 1, #apis do
		print("Loading "..apis[i].." API...")
		os.loadAPI(fs.combine(sApisPath, apis[i]))
	end
	local copy = {
		-- Global functions
		"assert", "dofile", "error", "getfenv", "getmetatable", "ipairs", "loadfile",
		"loadstring", "next", "pairs", "pcall", "rawequal", "rawget", "rawset",
		"select", "sleep", "setfenv", "setmetatable", "tonumber", "tostring",
		"type", "unpack", "xpcall", "__inext", "__VERSION",
		-- APIs
		"bit", "bit32", "colors", "colours", "coroutine", "crypto", "disk", "fs", "gps",
		"help", "io", "keys", "math", "os", "paintutils", "parallel", "peripheral",
		"redstone", "rednet", "rs", "string", "table", "textutils", "thread", "vector",
		-- DEBUG
		"emulog"
	}
	local main = {
		-- Global functions
		"print", "printError", "read", "write",
		-- APIs
		"graphics", "gui", "image", "term"
	}
	local env = getfenv()
	for i = 1, #copy do
		local k = copy[i]
		tMainEnv[k] = env[k]
		tBackgroundEnv[k] = env[k]
	end
	for i = 1, #main do
		tMainEnv[main[i]] = env[main[i]]
	end
	tMainEnv._G = tMainEnv
	tBackgroundEnv._G = tBackgroundEnv
end

-- Screen & Display

local screenWidth, screenHeight = screen.getSize()

local function showError(msg)
	-- TODO --
	emulog.log(msg)
end

-- Menus

local function newMenu(path)
	local ok, name = app.run(path, tMainEnv)
	if not ok then
		showError(name)
		return nil
	end
	return name
end

local bMenuOpen = false
local prevApp

local function openMenu(name)
	if not bMenuOpen then
		prevApp = app.getCurrent()
		bMenuOpen = true
	end
	app.switch(name)
end

local function closeMenu()
	if bMenuOpen then
		if not prevApp or not app.switch(prevApp) then
			app.stop()
		end
		bMenuOpen = false
	end
end

local function switchMenu(name)
	if app.getCurrent() == name then
		closeMenu()
	else
		openMenu(name)
	end
end

local homeMenu = newMenu("/MysticOS/menu/home")
local tasksMenu = newMenu("/MysticOS/menu/tasks")
local notifMenu = newMenu("/MysticOS/menu/notif")
local sysMenu = newMenu("/MysticOS/menu/sysmenu")

-- System Bar Buttons

local function home()
	switchMenu(homeMenu)
end

local function showTasks()
	switchMenu(tasksMenu)
end

local function showNotifications()
	switchMenu(notifMenu)
end

local function systemMenu()
	switchMenu(sysMenu)
end

local homeBtn = display.addButton(1, "M", colors.purple, colors.lightBlue, home)
local tasksBtn = display.addButton(2, "T", colors.blue, colors.lime, showTasks)
local notifBtn = display.addButton(screenWidth - 1, "N", colors.lightGray, colors.gray, showNotifications)
local systemBtn = display.addButton(screenWidth, "S", colors.blue, colors.white, systemMenu)

local function updateNotifications()
	if notifications.pending() then
		notifBtn:setBackgroundColor(colors.lime)
		notifBtn:setTextColor(colors.lightBlue)
	else
		notifBtn:setBackgroundColor(colors.lightGray)
		notifBtn:setTextColor(colors.gray)
	end
end

-- Event handlers

events.addHandler("terminate", function()
	app.kill()
end)

events.addHandler("key", function(key)
	if key == keys.f9 then
		-- Home
		home()
	elseif key == keys.f10 then
		-- Tasks
		showTasks()
	elseif key == keys.f11 then
		-- Notifications
		showNotifications()
	elseif key == keys.f12 then
		-- System menu
		systemMenu()
	else
		return false
	end
	return true
end)

events.addHandler("resize", function(w, h)
	screenWidth, screenHeight = w, h
	notifBtn:setPos(screenWidth - 1)
	systemBtn:setPos(screenWidth)
end)

events.addHandler("error", function(pid, tid, err)
	showError("Error (PID: "..pid.." TID: "..tid.."): "..err)
end)

events.addHandler("tick_end", function()
	if bSwitchApp then
		bSwitchApp = false
		closeMenu()
		app.switch(sAppName, unpack(tAppArgs))
	end
end)

events.addHandler("new_notification", updateNotifications)
events.addHandler("notification_removed", updateNotifications)

-- Initialize libraries

display.init()
app.init()
fs.init()

-- Initial render
display.redrawAll()

-- Start running
system.run()