-- MysticOS Users Library

-- User Levels
local nNormalLevel = 1
local nAdminLevel = 2

NormalLevel = nNormalLevel
AdminLevel = nAdminLevel

-- local vars and functions

local MinLevel = nNormalLevel
local MaxLevel = nAdminLevel

local tGroups
local tUsers

local function load_groups()
	if tGroups == nil then
		local file = fs.open("sys/groups", "r")
		if file then
			tGroups = {}
			local sLine = file.readLine()
			while sLine do
				local g, l = string.match(sLine, "(%w+) (%d)")
				if g and l then
					tGroups[g] = l
				end
				sLine = file.readLine()
			end
			file.close()
		end
	end
end

local function save_groups()
	if tGroups then
		local file = fs.open("sys/groups", "w")
		if not file then
			return false, "Error opening groups file."
		end
		for g, l in pairs(tGroups) do
			file.writeLine(g.." "..l)
		end
		file.close()
	end
	return true
end

local function load_users()
	if tUsers == nil then
		local file = fs.open("sys/users", "r")
		if file then
			tUsers = {}
			local sLine = file.readLine()
			while sLine do
				local u, p, g = string.match(sLine, "(%w+)%s(%w+)%s(%w+)")
				if u and p and g then
					tUsers[u] = {}
					tUsers[u].pass = p
					tUsers[u].group = g
				end
				sLine = file.readLine()
			end
			file.close()
		end
	end
end

local function save_users(tUsers)
	if tUsers then
		local file = fs.open("sys/users", "w")
		if not file then
			return false, "Error opening users file."
		end
		for u, t in pairs(tUsers) do
			file.writeLine(u.." "..t.pass.." "..t.group)
		end
		file.close()
	end
	return true
end

local function AddUser(sUser, sPass, sGroup)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tUsers[sUser] ~= nil then
		return false, "User already exists."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exist."
	end
	tUsers[sUser] = {}
	tUsers[sUser].pass = hash.sha256(sPass)
	tUsers[sUser].group = sGroup
	return save_users()
end

local function DelUser(sUser)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	if tUsers[sUser] == nil then
		return false, "User doesn't exists."
	end
	tUsers[sUser] = nil
	return save_users()
end

local function ChangePass(sUser, sPass)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	if tUsers[sUser] == nil then
		return false, "User doesn't exists."
	end
	tUsers[sUser].pass = hash.sha256(sPass)
	return save_users()
end

local function ChangeUserGroup(sUser, sGroup)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	if tUsers[sUser] == nil then
		return false, "Users doesn't exist."
	end
	load_groups()
	if tGroups == nil then
		return false, "Error loading groups."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exist."
	end
	tUsers[tUser].group = sGroup
	return save_users()
end

local function CheckUser(sUser, sPass)
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	return tUsers[sUser] ~= nil and hash.sha256(sPass) == tUsers[sUser].pass
end

local tReservedUserNames = { "System" }

local function ValidateUsername(sName)
	if #sName < 4 then
		return false, "Username is too short."
	elseif #sName > 16 then
		return false, "Username is too long."
	end
	if string.match(sName, "[^%w]") then
		return false, "Username can't contain spaces or symbols."
	end
	for _,name in ipairs(tReservedUserNames) do
		if sName == name then
			return false, "Invalid username."
		end
	end
	return true
end

local function AddGroup(sGroup, nLevel)
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tGroups[sGroup] then
		return false, "Group already exists."
	end
	if nLevel < MinLevel or nLevel > MaxLevel then
		return false, "Invalid level."
	end
	tGroups[sGroup] = nLevel
	return save_groups()
end

local function DelGroup(sGroup)
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exists."
	end
	load_users()
	if tUsers == nil then
		return false, "Error loading users."
	end
	for _,u in pairs(tUsers) do
		if u.group == sGroup then
			return false, "Can't remove group with users."
		end
	end
	tGroups[sGroup] = nil
	return save_groups()
end

local function ChangeGroupLevel(sGroup, nLevel)
	load_groups()
	if tGroups == nil then
		return false, "Error loading user groups."
	end
	if tGroups[sGroup] == nil then
		return false, "Group doesn't exist."
	end
	if nLevel < MinLevel or nLevel > MaxLevel then
		return false, "Invalid level."
	end
	tGroups[sGroup] = nLevel
	return save_groups()
end

local tReservedGroupNames = { "System" }

local function ValidateGroupName(sName)
	if #sName < 4 then
		return false, "Group Name is too short."
	elseif #sName > 16 then
		return false, "Group Name is too long."
	end
	if string.match(sName, "[^%w]") then
		return false, "Group Name can't contain spaces or symbols."
	end
	for _,name in ipairs(tReservedGroupNames) do
		if sName == name then
			return false, "Invalid group name."
		end
	end
	return true
end

-- Lib functions

local bLogged = false
local sCurUser = ""

function login(sUser, sPass)
	if bLogged then
		if sUser ~= sCurUser then
			return false, "There's another user logged"
		end
		return true
	end
	if not CheckUser(sUser, sPass) then
		return false, "Invalid username/password."
	end
	bLogged = true
	sCurUser = sUser
	return true
end

function logout()
	bLogged = false
	sCurUser = ""
end

function isLogged()
	return bLogged
end

function current()
	return bLogged and sCurUser or "System"
end

function currentGroup()
	return bLogged and tUsers[sCurUser].group or "System"
end

function getLevel()
	load_groups()
	if tGroups == nil then
		return nil, "Error loading user groups."
	end
	return tGroups[tUsers[sCurUser].group]
end

function isAdmin()
	return not bLogged or getLevel() >= nAdminLevel
end

function createUser(sUser, sPass, sGroup)
	if not isAdmin() then
		return false, "Admin level required."
	end
	local ok, err = ValidateUsername(sUser)
	if not ok then
		return false, err
	end
	ok, err = AddUser(sUser, sPass, sGroup)
	if not ok then
		return false, err
	end
	--[[
	-- TODO: user directory (home)?
	fs.copy("system/common", fs.combine("home", sUser))
	--]]
	return true
end

function removeUser(sUser)
	if not isAdmin() then
		return false, "Admin level required."
	end
	if sUser == sCurUser then
		return false, "Can't remove current user."
	end
	local ok, err = DelUser(sUser)
	if not ok then
		return false, err
	end
	--[[
	-- TODO: user directory (home)?
	fs.delete(fs.combine("home", sUser))
	--]]
	return true
end

function changePassword(sUser, sOldPass, sNewPass)
	if sUser ~= sCurUser and not isAdmin() then
		return false, "Admin level required."
	end
	local ok, err = CheckUser(sUser, sOldPass)
	if not ok then
		return false, err
	end
	return ChangePass(sUser, sNewPass)
end

function createGroup(sGroup, nLevel)
	if not isAdmin() then
		return false, "Admin level required."
	end
	local ok, err = ValidateGroupName(sGroup)
	if not ok then
		return false, err
	end
	return AddGroup(sGroup, nLevel)
end

function removeGroup(sGroup)
	if not isAdmin() then
		return false, "Admin level required."
	end
	return DelGroup(sGroup)
end

function changeGroupLevel(sGroup, nLevel)
	if not isAdmin() then
		return false, "Admin level required."
	end
	return ChangeGroupLevel(sGroup, nLevel)
end

function getUsers()
	load_users()
	if tUsers == nil then
		return nil, "Error loading users."
	end
	local t = {}
	for name,_ in pairs(tUsers) do
		table.insert(t, name)
	end
	return t
end

function getUserCount()
	load_users()
	if tUsers == nil then
		return 0
	end
	return #tUsers
end

function getGroups()
	load_groups()
	if tGroups == nil then
		return nil, "Error loading groups."
	end
	local t = {}
	for name,_ in pairs(tGroups) do
		table.insert(t, name)
	end
	return t
end

function getGroupCount()
	load_groups()
	if tGroups == nil then
		return 0
	end
	return #tGroups
end

function runAsAdmin(sUsr, sPass, func, ...)
	-- TODO
end
