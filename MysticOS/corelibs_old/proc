-- MysticOS Process Library

local proc = {}

local tRunningQueue = {}
local tReadyQueue = {}
local nPID = 0
local nRunningProcess = 0
local nRunningThread = 0

function proc.new(sName, tEnv)
	tEnv = tEnv or getfenv() -- TODO
	nPID = nPID + 1
	local tProc = {}
	tProc.id = nPID
	tProc.name = sName
	tProc.tid = 0
	tProc.runningThreads = {}
	tProc.readyThreads = {}
	tProc.openHandles = {}
	tProc.filters = {}
	tProc.env = {}
	tProc.env._G = tProc.env
	setmetatable(tProc.env, { __index = tEnv })
	table.insert(tReadyQueue, tProc)
	return nPID
end

local function get(pid)
	for _,tProc in ipairs(tRunningQueue) do
		if tProc.id == pid then
			return tProc
		end
	end
	for _,tProc in ipairs(tReadyQueue) do
		if tProc.id == pid then
			return tProc
		end
	end
	return nil
end

function proc.openHandle(pid, handle)
	local tProc = get(pid)
	if tProc then
		table.insert(tProc.openHandles, handle)
	end
end

function proc.closeHandle(pid, handle)
	local tProc = get(pid)
	if tProc then
		for i, h in ipairs(tProc.openHandles) do
			if h == handle then
				table.remove(tProc.openHandles, i)
				break
			end
		end
	end
end

local function killProc(tProc)
	-- close file handles
	for _,handle in ipairs(tProc.openHandles) do
		handle.close()
	end
end

function proc.kill(pid)
	for i, tProc in ipairs(tRunningQueue) do
		if tProc.id == pid then
			killProc(tRunningQueue[i])
			table.remove(tRunningQueue, i)
			return true
		end
	end
	for i, tProc in ipairs(tReadyQueue) do
		if tProc.id == pid then
			killProc(tReadyQueue[i])
			table.remove(tReadyQueue, i)
			return true
		end
	end
	return false
end

function proc.list()
	local t = {}
	for _,tProc in ipairs(tReadyQueue) do
		local p = {}
		p.id = tProc.id
		p.name = tProc.name
		table.insert(t, p)
	end
	for _,tProc in ipairs(tRunningQueue) do
		local p = {}
		p.id = tProc.id
		p.name = tProc.name
		table.insert(t, p)
	end
	return t
end

function proc.count()
	return #tReadyQueue + #tRunningQueue
end

function proc.running()
	return nRunningProcess
end

local function addThread(tProc, thread)
	tProc.tid = tProc.tid + 1
	table.insert(tProc.readyThreads, thread)
	return tProc.tid
end

function proc.createThread(pid, func)
	local tProc = get(pid)
	if tProc then
		setfenv(func, tProc.env)
		local co = coroutine.create(func)
		if co then
			local thread = {}
			thread.id = addThread(tProc, thread)
			thread.routine = co
			return thread.id
		end
	end
	return nil
end

function proc.killThread(pid, tid)
	local tProc = get(pid)
	if tProc then
		for i, thread in ipairs(tProc.runningThreads) do
			if thread.id == tid then
				table.remove(tProc.runningThreads, i)
				return true
			end
		end
		for i, thread in ipairs(tProc.readyThreads) do
			if thread.id == tid then
				table.remove(tProc.readyThreads, i)
				return true
			end
		end
	end
	return false
end

function proc.listThreads(pid)
	local tProc = get(pid)
	if tProc then
		local t = {}
		for _,thread in ipairs(tProc.readyThreads) do
			table.insert(t, thread.id)
		end
		for _,thread in ipairs(tProc.runningThreads) do
			table.insert(t, thread.id)
		end
		return t
	end
	return nil
end

function proc.threadCount(pid)
	local tProc = get(pid)
	if tProc then
		return #tProc.readyThreads + #tProc.runningThreads
	end
	return nil
end

function proc.runningThread()
	return nRunningThread
end

-- Run functions

local function updateThreads(tProc)
	for i, v in ipairs(tProc.readyThreads) do
		table.insert(tProc.runningThreads, v)
		table.remove(tProc.readyThreads, i)
	end
end

local function updateProcs()
	for i, v in ipairs(tReadyQueue) do
		table.insert(tRunningQueue, v)
		table.remove(tReadyQueue, i)
		updateThreads(v)
	end
end

local function checkFilter(sEvt, tFilter)
	if sEvt == nil or tFilter == nil or #tFilter == 0 then
		return true
	end
	for _,filter in ipairs(tFilter) do
		if filter == sEvt then
			return true
		end
	end
	return false
end

local function runProcesses(sEvt, ...)
	for _,tProc in ipairs(tRunningQueue) do
		nRunningProcess = tProc.id
		for _,thread in ipairs(tProc.runningThreads) do
			if checkFilter(sEvt, tProc.filters[thread.id]) then
				nRunningThread = thread.id
				local tStatus = { coroutine.resume(thread.routine, sEvt, ...) }
				if coroutine.status(thread.routine) == "dead" then
					killThread(tProc.id, thread.id)
				else
					tProc.filters[thread.id] = { unpack(tStatus, 2) }
				end
			end
		end
		if proc.threadCount(tProc.pid) == 0 then
			proc.kill(tProc.id)
		end
	end
end

local function runEvent(sEvt, ...)
	if not system.handleEvent(sEvt, ...) then
		runProcesses(sEvt, ...)
	end
end

function proc.run()
	local tEvt = {}
	while system.isRunning() and proc.count() > 0 do
		updateProcs()
		runEvent(unpack(tEvt))
		if system.isRunning() then
			tEvt = { coroutine.yield() }
		end
	end
end

return proc
