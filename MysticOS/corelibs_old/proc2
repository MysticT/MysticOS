-- MysticOS Processes Library

local tReadyQueue = {}
local tRunningQueue = {}
local tBlockedQueue = {}
local nPID = 0
local nRunningProcess
local nRunningThread
local tKillList = {}
local tBlockList = {}

local function checkFilter(sEvt, tFilter)
	if sEvt == nil or tFilter == nil or #tFilter == 0 then
		return true
	end
	for i = 1, #tFilter do
		if tFilter[i] == sEvt then
			return true
		end
	end
	return false
end

-- Thread

local Thread = {}

function Thread:getID()
	return self.id
end

function Thread:status()
	return coroutine.status(self.routine)
end

function Thread:isRunning()
	return self.running
end

function Thread:stop()
	self.running = false
end

function Thread:resume()
	self.running = true
end

function Thread:run(sEvt, ...)
	if self:isRunning() then
		nRunningThread = self.id
		local tStatus = { coroutine.resume(self.routine, sEvt, ...) }
		if self:status() == "dead" then
			if not tStatus[1] then
				system.handleError(nRunningProcess, bRunningThread, tStatus[2])
			end
			return false
		end
		return true, { unpack(tStatus, 2) }
	end
end

local function newThread(id, func)
	local co = coroutine.create(func)
	if co then
		local thread = {}
		thread.id = id
		thread.routine = co
		thread.running = true
		return setmetatable(thread, { __index = Thread })
	end
end

-- Process

local Proc = {}

function Proc:getID()
	return self.id
end

function Proc:getName()
	return self.name
end

function Proc:isRunning()
	return self.running
end

function Proc:kill()
	self.running = false
end

function Proc:block()
	self.running = false
end

function Proc:resume()
	self.running = true
end

function Proc:run(sEvt, ...)
	if self:isRunning() then
		nRunningProcess = self
		for i = 1, #tProc.runningThreads do
			local thread = self.runningThreads[i]
			if checkFilter(sEvt, self.filters[thread:getID()]) then
				local ok, filters = thread:run(sEvt, ...)
				if ok then
					self.filters[thread:getID()] = filters
				else
					self.killList[thread:getID()] = true
				end
			end
		end
	end
end

function Proc:addThread(func)
	setfenv(func, self.env)
	local thread = newThread(func, self.tid)
	if thread then
		-- TODO: run thread once?
		self.tid = self.tid + 1
		self.readyThreads[#self.readyThreads + 1] = thread
		return true, thread:getID()
	end
	return false, "Error creating new coroutine"
end

function Proc:stopThread(id)
	for i = 1, #self.runningThreads do
		if self.runningThreads[i]:getID() == pid then
			self.runningThreads[i]:stop()
			self.stopList[self.runningThreads[i]:getID()] = true
			return true
		end
	end
	for i = 1, #self.readyThreads do
		if self.readyThreads[i]:getID() == pid then
			self.readyThreads[i]:stop()
			self.blockedThreads[#self.blockedThreads + 1] = self.readyThreads[i]
			table.remove(self.readyThreads, i)
			return true
		end
	end
	return false
end

function Proc:resumeThread(pid)
	for i = 1, #self.blockedThreads do
		if self.blockedThreads[i]:getID() == pid then
			self.blockedThreads[i]:resume()
			self.readyThreads[#self.readyThreads + 1] = self.blockedThreads[i]
			table.remove(self.blockedThreads, i)
			return true
		end
	end
	return false
end

function Proc:killThread(id)
	for i = 1, #self.runningThreads do
		if self.runningThreads[i]:getID() == id then
			self.runningThreads[i]:stop()
			self.killList[self.runningThreads[i]:getID()] = true
			return true
		end
	end
	for i = 1, #self.blockedThreads do
		if self.blockedThreads[i]:getID() == id then
			table.remove(self.blockedThreads, i)
			self.filters[id] = nil
			return true
		end
	end
	for i = 1, #self.readyThreads do
		if self.readyThreads[i]:getID() == id then
			table.remove(self.readyThreads, i)
			self.filters[id] = nil
			return true
		end
	end
	return false
end

function Proc:listThreads()
	local l = {}
	for i = 1, #self.runningThreads do
		l[#l + 1] = self.runningThreads[i]:getID()
	end
	for i = 1, #self.readyThreads do
		l[#l + 1] = self.readyThreads[i]:getID()
	end
	for i = 1, #self.blockedThreads do
		l[#l + 1] = self.blockedThreads[i]:getID()
	end
	return l
end

function Proc:threadCount()
	return #self.runningThreads + #self.readyThreads + #self.blockedThreads
end

function Proc:updateThreads()
	for id in pairs(self.killList) do
		for i = 1, #self.runningThreads do
			if self.runningThreads[i]:getID() == id then
				table.remove(self.runningThreads, i)
				self.filters[id] = nil
				break
			end
		end
	end
	table.clear(self.killList)
	for id in pairs(self.stopList) do
		for i = 1, #self.runningThreads do
			if self.runningThreads[i]:getID() == id then
				self.blockedThreads[#self.blockedThreads + 1] = self.runningThreads[i]
				table.remove(self.runningThreads, i)
				break
			end
		end
	end
	table.clear(self.stopList)
	table.append(self.runningThreads, self.readyThreads)
	table.clear(self.readyThreads)
end

local function newProcess(name, env)
	nPID = nPID + 1
	local tProc = {}
	tProc.id = nPID
	tProc.name = name
	tProc.running = true
	tProc.tid = 1
	tProc.runningThreads = {}
	tProc.readyThreads = {}
	tProc.filters = {}
	tProc.env = setmetatable({}, { __index = env })
	tProc.env._G = tProc.env
	return setmetatable(tProc, { __index = Proc })
end

-- API

function createProcess(name, tEnv)
	local tProc = newProcess(name, tEnv)
	tReadyQueue[#tReadyQueue + 1] = tProc
	return tProc:getID()
end

function getProcess(pid)
	pid = pid or nRunningProcess
	for i = 1, #tRunningQueue do
		if tRunningQueue[i]:getID() == pid then
			return tRunningQueue[i]
		end
	end
	for i = 1, #tBlockedQueue do
		if tBlockedQueue[i]:getID() == pid then
			return tBlockedQueue[i]
		end
	end
	for i = 1, #tReadyQueue do
		if tReadyQueue[i]:getID() == pid then
			return tReadyQueue[i]
		end
	end
	return nil
end

function block(pid)
	for i = 1, #tRunningQueue do
		if tRunningQueue[i]:getID() == pid then
			tRunningQueue[i]:block()
			tBlockList[pid] = true
			return true
		end
	end
	for i = 1, #tReadyQueue do
		if tReadyQueue[i]:getID() == pid then
			tReadyQueue[i]:block()
			tBlockedQueue[#tBlockedQueue + 1] = tReadyQueue[i]
			table.remove(tReadyQueue, i)
			return true
		end
	end
	return false
end

function resume(pid)
	for i = 1, #tBlockedQueue do
		if tBlockedQueue[i]:getID() == pid then
			tBlockedQueue[i]:resume()
			tReadyQueue[#tReadyQueue + 1] = tBlockedQueue[i]
			table.remove(tBlockedQueue, i)
			return true
		end
	end
	return false
end

function kill(pid)
	for i = 1, #tRunningQueue do
		if tRunningQueue[i]:getID() == pid then
			tRunningQueue[i]:kill()
			tKillList[pid] = true
			return true
		end
	end
	for i = 1, #tBlockedQueue do
		if tBlockedQueue[i]:getID() == pid then
			tBlockedQueue[i]:kill()
			table.remove(tBlockedQueue, i)
			return true
		end
	end
	for i = 1, #tReadyQueue do
		if tReadyQueue[i]:getID() == pid then
			tReadyQueue[i]:kill()
			table.remove(tReadyQueue, i)
			return true
		end
	end
	return false
end

function list()
	local l = {}
	for i = 1, #tRunningQueue do
		local p = {}
		p.id = tRunningQueue[i]:getID()
		p.name = tRunningQueue[i]:getName()
		l[#l + 1] = p
	end
	for i = 1, #tReadyQueue do
		local p = {}
		p.id = tReadyQueue[i]:getID()
		p.name = tReadyQueue[i]:getName()
		l[#l + 1] = p
	end
	for i = 1, #tBlockedQueue do
		local p = {}
		p.id = tBlockedQueue[i]:getID()
		p.name = tBlockedQueue[i]:getName()
		l[#l + 1] = p
	end
	return l
end

function count()
	return #tRunningQueue + #tReadyQueue + #tBlockedQueue
end

function running()
	return nRunningProcess
end

function createThread(func, pid)
	local tProc = getProcess(pid)
	if tProc then
		return tProc:createThread(func)
	end
	return false, "No process with id #"..pid
end

function killThread(tid, pid)
	local tProc = getProcess(pid)
	if tProc then
		tProc:killThread(tid)
	end
	return false
end

function listThreads(pid)
	local tProc = getProcess(pid)
	if tProc then
		return tProc:listThreads()
	end
	return nil
end

function threadCount(pid)
	local tProc = getProcess(pid)
	if tProc then
		return tProc:threadCount()
	end
	return nil
end

function runningThread()
	return nRunningThread
end

-- Run functions

local function updateProcs()
	for id in pairs(tKillList) do
		for i = 1, #tRunningQueue do
			if tRunningQueue[i]:getID() == id then
				table.remove(tRunningQueue, i)
				break
			end
		end
	end
	table.clear(tKillList)
	for id in pairs(tBlockList) do
		for i = 1, #tRunningQueue do
			if tRunningQueue[i]:getID() == id then
				tBlockedQueue[#tBlockedQueue + 1] = tRunningQueue[i]
				table.remove(tRunningQueue, i)
				break
			end
		end
	end
	table.clear(tBlockList)
	table.append(tRunningQueue, tReadyQueue)
	table.clear(tReadyQueue)
	for i = 1, #tRunningQueue do
		tRunningQueue[i]:updateThreads()
	end
end

local function runProc(tProc, sEvt, ...)
	tProc:run(sEvt, ...)
end

local function runProcesses(sEvt, ...)
	for i = 1, #tRunningQueue do
		local tProc = tRunningQueue[i]
		tProc:run(sEvt, ...)
		if tProc:threadCount() == 0 then
			tProc:kill()
			tKillList[tProc:getID()] = true
		end
	end
end

local function runEvent(sEvt, ...)
	if not system.handleEvent(sEvt, ...) then
		runProcesses(sEvt, ...)
	end
end

function run()
	local tEvt = {}
	while system.isRunning() do
		updateProcs()
		runEvent(unpack(tEvt))
		if system.isRunning() then
			tEvt = { coroutine.yield() }
		end
	end
end